[{
  "history_id" : "85wzlk058y5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167825374,
  "history_end_time" : 1666167825374,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "75boudmf3hf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167772355,
  "history_end_time" : 1666167772355,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "6vnfttta0rv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166465606,
  "history_end_time" : 1666166465606,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "eawgwanqjyn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166410280,
  "history_end_time" : 1666166419945,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "gfak55akjkl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666164233094,
  "history_end_time" : 1666164233094,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sp3ws4v3hh2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666163607305,
  "history_end_time" : 1666163607305,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ckyq575uv1j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666137012952,
  "history_end_time" : 1666137012952,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "c4wlv1rb7zs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136593510,
  "history_end_time" : 1666136593510,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "9gswgufosmu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136435816,
  "history_end_time" : 1666136435816,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "z6nt2pnuzk4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134110782,
  "history_end_time" : 1666134110782,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fuo710d0w4o",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134036934,
  "history_end_time" : 1666134036934,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "6qgoc09hbzu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134008986,
  "history_end_time" : 1666134008986,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "y8j7wahsxcg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666131993213,
  "history_end_time" : 1666131993213,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "dihj0nxbwcq",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1666118284123,
  "history_end_time" : 1666118290260,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "uk2fyd0pl88",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1655909884594,
  "history_end_time" : 1655909888515,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "5fo5q2y6x08",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_pv_kenya.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 227, in <module>\n    PYPROJ_LT_3 = LooseVersion(pyproj.__version__) < LooseVersion(\"3\")\nAttributeError: module 'pyproj' has no attribute '__version__'\n",
  "history_begin_time" : 1655908830458,
  "history_end_time" : 1655908831221,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "o67me90twg7",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_pv_kenya.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 9, in <module>\n    import pyproj\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/__init__.py\", line 81, in <module>\n    from pyproj.crs import CRS  # noqa: F401\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/__init__.py\", line 16, in <module>\n    from pyproj.crs.crs import (  # noqa: F401  pylint: disable=unused-import\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/crs.py\", line 13, in <module>\n    from pyproj._crs import (\nImportError: cannot import name 'AuthorityMatchInfo' from 'pyproj._crs' (/opt/anaconda3/lib/python3.8/site-packages/pyproj/_crs.cpython-38-darwin.so)\n",
  "history_begin_time" : 1655907441445,
  "history_end_time" : 1655907442388,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "anu28twmgv3",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_pv_kenya.py\", line 2, in <module>\n    import pandas as pd\nModuleNotFoundError: No module named 'pandas'\n",
  "history_begin_time" : 1655865868673,
  "history_end_time" : 1655865868848,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "g7h39uhg9ce",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_pv_kenya.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 9, in <module>\n    import pyproj\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/__init__.py\", line 81, in <module>\n    from pyproj.crs import CRS  # noqa: F401\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/__init__.py\", line 16, in <module>\n    from pyproj.crs.crs import (  # noqa: F401  pylint: disable=unused-import\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/crs.py\", line 13, in <module>\n    from pyproj._crs import (\nImportError: cannot import name 'AuthorityMatchInfo' from 'pyproj._crs' (/opt/anaconda3/lib/python3.8/site-packages/pyproj/_crs.cpython-38-darwin.so)\n",
  "history_begin_time" : 1655865097515,
  "history_end_time" : 1655865098678,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "9bq6iqp77o5",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347442176,
  "history_end_time" : 1647347442865,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ms8mfh6xot7",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347347651,
  "history_end_time" : 1647347349139,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "9q38m0sdlz6",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347285839,
  "history_end_time" : 1647347286569,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "lue1gbluazk",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347145369,
  "history_end_time" : 1647347145763,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ma975e2k9k7",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647346819016,
  "history_end_time" : 1647346822567,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "2dphb8jq7rx",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647346659270,
  "history_end_time" : 1647346662315,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "si9co6atn12",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647345853979,
  "history_end_time" : 1647345856881,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "jad4qvevzww",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647345672051,
  "history_end_time" : 1647345675094,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "9o346lei6t6",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1647340133032,
  "history_end_time" : 1647340134120,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "dqogu96bqmn",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1646147726406,
  "history_end_time" : 1646147727925,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "qy9yc1dnl0g",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138281518,
  "history_end_time" : 1646138285571,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "57zsgkk632x",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138181872,
  "history_end_time" : 1646138183053,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "yljnuu3qkmc",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138108623,
  "history_end_time" : 1646138111914,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "g4je9zv0poj",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137793613,
  "history_end_time" : 1646137796733,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "0ahbbpqz3tn",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137697444,
  "history_end_time" : 1646137698549,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "s8ru7eq9g3p",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\n\nfrom typing import Optional\n\n\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_pv_kenya import KenyaPVSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass PVKenyaEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaPVSentinelExporter.dataset\n    dataset = KenyaPVProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Plant Village processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        else:\n            label_lat = overlap.iloc[0].lat\n            label_lon = overlap.iloc[0].lon\n\n            is_crop = bool(overlap.iloc[0].is_crop)\n\n            closest_lon, _ = self.find_nearest(da.x, label_lon)\n            closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n            labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n            if add_ndvi:\n                labelled_np = self.calculate_ndvi(labelled_np)\n            if add_ndwi:\n                labelled_np = self.calculate_ndwi(labelled_np)\n\n            labelled_array = self.maxed_nan_to_num(\n                labelled_np, nan=nan_fill, max_ratio=max_nan_ratio\n            )\n\n            if (not is_test) and calculate_normalizing_dict:\n                self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n            if labelled_array is not None:\n                return DataInstance(\n                    label_lat=label_lat,\n                    label_lon=label_lon,\n                    instance_lat=closest_lat,\n                    instance_lon=closest_lon,\n                    labelled_array=labelled_array,\n                    is_crop=is_crop,\n                    dataset=self.dataset,\n                )\n            else:\n                return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137582315,
  "history_end_time" : 1646137582542,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "u77bnyqo5pn",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1655907403209,
  "history_notes" : null,
  "history_process" : "s024ve",
  "host_id" : "100001",
  "indicator" : "Stopped"
},]
