[{
  "history_id" : "yim308xagyd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167825340,
  "history_end_time" : 1666167825340,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8aj539z45ng",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167772300,
  "history_end_time" : 1666167772300,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "moml0plq7l2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166465575,
  "history_end_time" : 1666166465575,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "umyxm3g7g6f",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166410237,
  "history_end_time" : 1666166419927,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "4my1e4c4rmk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666164233061,
  "history_end_time" : 1666164233061,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "4s2aogn4rn1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666163607256,
  "history_end_time" : 1666163607256,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ddrthzmkrm9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666137012929,
  "history_end_time" : 1666137012929,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "oeaemg89zqh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136593470,
  "history_end_time" : 1666136593470,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "565jcxag6fb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136435748,
  "history_end_time" : 1666136435748,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3jbj300mlsy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134110729,
  "history_end_time" : 1666134110729,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3sjqwytnquk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134036880,
  "history_end_time" : 1666134036880,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ixkso85obl3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134008932,
  "history_end_time" : 1666134008932,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "n0wuwkk91yg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666131993129,
  "history_end_time" : 1666131993129,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "tv6jwg0ssq3",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1666118293291,
  "history_end_time" : 1666118293902,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "rc5wue5w6ed",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1655909880957,
  "history_end_time" : 1655909883890,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "zgyn5s06iij",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_exporters_sentinel_pv_kenya.py\", line 2, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 227, in <module>\n    PYPROJ_LT_3 = LooseVersion(pyproj.__version__) < LooseVersion(\"3\")\nAttributeError: module 'pyproj' has no attribute '__version__'\n",
  "history_begin_time" : 1655908827556,
  "history_end_time" : 1655908828445,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "76ly6ln7l66",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_exporters_sentinel_pv_kenya.py\", line 2, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 9, in <module>\n    import pyproj\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/__init__.py\", line 81, in <module>\n    from pyproj.crs import CRS  # noqa: F401\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/__init__.py\", line 16, in <module>\n    from pyproj.crs.crs import (  # noqa: F401  pylint: disable=unused-import\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/crs.py\", line 13, in <module>\n    from pyproj._crs import (\nImportError: cannot import name 'AuthorityMatchInfo' from 'pyproj._crs' (/opt/anaconda3/lib/python3.8/site-packages/pyproj/_crs.cpython-38-darwin.so)\n",
  "history_begin_time" : 1655907428932,
  "history_end_time" : 1655907429868,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "wxy4vuucr8e",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1655907396305,
  "history_end_time" : 1655907403079,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "reti3pnlxyv",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_exporters_sentinel_pv_kenya.py\", line 1, in <module>\n    import pandas as pd\nModuleNotFoundError: No module named 'pandas'\n",
  "history_begin_time" : 1655865862879,
  "history_end_time" : 1655865863030,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "s27isk5lfct",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1655865100702,
  "history_end_time" : 1655865101127,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ob5vmbqpckn",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647347435917,
  "history_end_time" : 1647347436338,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "0frentzwp9p",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647347338923,
  "history_end_time" : 1647347341055,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "cub848sz78s",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647347275486,
  "history_end_time" : 1647347277530,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "p4akurbw6dl",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647347149277,
  "history_end_time" : 1647347149850,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "gig1pfr2ler",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647346824585,
  "history_end_time" : 1647346826860,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "madyxs3lrln",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647346646320,
  "history_end_time" : 1647346646743,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ilonsds6m7s",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647345839985,
  "history_end_time" : 1647345840506,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "z8u17xyi9tb",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647345669652,
  "history_end_time" : 1647345671849,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "u27ui287gdg",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1647340122307,
  "history_end_time" : 1647340122559,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "k5yr9fplfke",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646147720176,
  "history_end_time" : 1646147723184,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "wgxc3j6brjq",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646145432286,
  "history_end_time" : 1646145433622,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "jdksk6os5nz",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646145216560,
  "history_end_time" : 1646145219038,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "8vkjeaexu0p",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646144606470,
  "history_end_time" : 1646144607399,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "enlh6sf5mud",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646144386829,
  "history_end_time" : 1646144389442,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "7dvdp9j3qeg",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646144314058,
  "history_end_time" : 1646144314233,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "fc1h7697dj1",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646143410336,
  "history_end_time" : 1646143412529,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "g2z716tg789",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646143255601,
  "history_end_time" : 1646143257880,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "f0duddtlakm",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646143178625,
  "history_end_time" : 1646143181193,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "d6zvo9x1z47",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646143140419,
  "history_end_time" : 1646143140533,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "xzyuszc71kd",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646143118225,
  "history_end_time" : 1646143118295,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "5navl088o7o",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646139380305,
  "history_end_time" : 1646139382316,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "8cq8qwb2hm0",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646139290981,
  "history_end_time" : 1646139291219,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "nhlkqinfvgg",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646139248706,
  "history_end_time" : 1646139248764,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "l6jodlnwuvy",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646139197661,
  "history_end_time" : 1646139198663,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "laxwrkaga8o",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646139156805,
  "history_end_time" : 1646139158978,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "1kszbl3fwm2",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646138499588,
  "history_end_time" : 1646138501645,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "6kfrbszwop3",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646138448350,
  "history_end_time" : 1646138450459,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "c7niyhffnda",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646138402670,
  "history_end_time" : 1646138403283,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "xcbx7mzp8ih",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646138278476,
  "history_end_time" : 1646138279524,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "2ce4wqm5f57",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646138176256,
  "history_end_time" : 1646138176443,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "at15x8y38et",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646138104140,
  "history_end_time" : 1646138106765,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "djx0ahiy8jh",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646137779744,
  "history_end_time" : 1646137781111,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "xenuhvyppst",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646137689993,
  "history_end_time" : 1646137690193,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "6q63gftojvv",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646137582626,
  "history_end_time" : 1646137584457,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "otx0u72lqf4",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646112830643,
  "history_end_time" : 1646112833115,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "avmbb2z3oxm",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646112721384,
  "history_end_time" : 1646112723788,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "r0szbi5tv0p",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646112280563,
  "history_end_time" : 1646112282430,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "7i97wacez4w",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646112238205,
  "history_end_time" : 1646112238335,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3nn5xzn3ybt",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1646112143810,
  "history_end_time" : 1646112144322,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "tc03bv74s8p",
  "history_input" : "import pandas as pd\nimport geopandas\nfrom tqdm import tqdm\nimport numpy as np\nfrom datetime import datetime, timedelta, date\n\nfrom src_exporters_sentinel_base import BaseSentinelExporter\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_exporters_sentinel_utils import EEBoundingBox, bounding_box_from_centre, date_overlap\n\nfrom typing import Dict, Optional, List, Tuple\n\n\nclass KenyaPVSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_plant_village_kenya\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        plantvillage = self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        assert plantvillage.exists(), \"Plant Village processor must be run to load labels\"\n        return geopandas.read_file(plantvillage)[\n            [\"lat\", \"lon\", \"index\", \"planting_date\", \"harvest_date\"]\n        ]\n\n    @staticmethod\n    def overlapping_year(\n        end_month: int, num_days: int, harvest_date: date, planting_date: date\n    ) -> Tuple[Optional[int], Optional[int]]:\n        r\"\"\"\n        Return the end_year of the most overlapping years\n        \"\"\"\n        harvest_year = harvest_date.year\n\n        overlap_dict: Dict[int, int] = {}\n\n        for diff in range(-1, 2):\n            end_date = date(harvest_year + diff, end_month, 1)\n\n            if end_date > datetime.now().date():\n                continue\n            else:\n                overlap_dict[harvest_year + diff] = date_overlap(\n                    planting_date, harvest_date, end_date - timedelta(days=num_days), end_date,\n                )\n        if len(overlap_dict) > 0:\n            return max(overlap_dict.items(), key=lambda x: x[1])\n        else:\n            # sometimes the harvest date is in the future? in which case\n            # we will just skip the datapoint for now\n            return None, None\n\n    def labels_to_bounding_boxes(\n        self,\n        num_labelled_points: Optional[int],\n        surrounding_metres: int,\n        end_month_day: Optional[Tuple[int, int]],\n        num_days: int,\n    ) -> List[Tuple[int, EEBoundingBox, date, Optional[int]]]:\n\n        output: List[Tuple[int, EEBoundingBox, date, Optional[int]]] = []\n\n        if end_month_day is not None:\n            end_month: Optional[int]\n            end_day: Optional[int]\n            end_month, end_day = end_month_day\n        else:\n            end_month = end_day = None\n\n        for idx, row in tqdm(self.labels.iterrows()):\n\n            try:\n                harvest_date = datetime.strptime(row[\"harvest_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n            except ValueError:\n                continue\n\n            # this is only used if end_month is not None\n            overlapping_days: Optional[int] = 0\n            if end_month is not None:\n                planting_date = datetime.strptime(row[\"planting_date\"], \"%Y-%m-%dT%H:%M:%S\").date()\n\n                end_year, overlapping_days = self.overlapping_year(\n                    end_month, num_days, harvest_date, planting_date\n                )\n\n                if end_year is None:\n                    continue\n\n                if end_day is None:\n                    # if no end_day is passed, we will take the first month\n                    end_day = 1\n                harvest_date = date(end_year, end_month, end_day)\n\n            output.append(\n                (\n                    row[\"index\"],\n                    bounding_box_from_centre(\n                        mid_lat=row[\"lat\"],\n                        mid_lon=row[\"lon\"],\n                        surrounding_metres=surrounding_metres,\n                    ),\n                    harvest_date,\n                    overlapping_days,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def get_start_and_end_dates(\n        self, harvest_date: date, days_per_timestep: int, num_timesteps: int\n    ) -> Optional[Tuple[date, date]]:\n\n        if harvest_date < self.min_date:\n            print(\"Harvest date < min date - skipping\")\n            return None\n        else:\n            start_date = max(\n                harvest_date - timedelta(days_per_timestep * num_timesteps), self.min_date,\n            )\n            end_date = start_date + timedelta(days_per_timestep * num_timesteps)\n\n            return start_date, end_date\n\n    def export_for_labels(\n        self,\n        end_month_day: Optional[Tuple[int, int]] = (4, 16),\n        days_per_timestep: int = 30,\n        num_timesteps: int = 12,\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        :param end_month_day: The final month-day to use. If None is passed, the harvest date\n            will be used. Default = (4, 16)\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n            Default = 30\n        :param num_timesteps: The number of timesteps to export. Default = 12\n        :param num_labelled_points: If not None, then only this many points will be exported.\n            Default = None.\n        :param surrouning_metres: The patch will be [2 * surrounding_metres,\n            2 * surrounding_metres], centered around the labelled point. Default = 80\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it. Default = True\n        :param monitor: Whether to monitor each task until it has been run. Default = True\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points,\n            surrounding_metres=surrounding_metres,\n            end_month_day=end_month_day,\n            num_days=days_per_timestep * num_timesteps,\n        )\n\n        if end_month_day is not None:\n            print(\n                f\"Average overlapping days between planting to harvest and \"\n                f\"export dates: {np.mean([x[3] for x in bounding_boxes_to_download])}\"\n            )\n        for idx, bounding_info in enumerate(bounding_boxes_to_download):\n\n            harvest_date = bounding_info[-2]\n\n            dates = self.get_start_and_end_dates(harvest_date, days_per_timestep, num_timesteps)\n\n            if dates is not None:\n\n                self._export_for_polygon(\n                    polygon=bounding_info[1].to_ee_polygon(),\n                    polygon_identifier=bounding_info[0],\n                    start_date=dates[0],\n                    end_date=dates[1],\n                    days_per_timestep=days_per_timestep,\n                    checkpoint=checkpoint,\n                    monitor=monitor,\n                    fast=fast,\n                )\n",
  "history_output" : "",
  "history_begin_time" : 1645393381531,
  "history_end_time" : 1645393384297,
  "history_notes" : null,
  "history_process" : "i4s7l1",
  "host_id" : "100001",
  "indicator" : "Done"
},]
