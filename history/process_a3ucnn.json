[{
  "history_id" : "3of9mwokorb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167825380,
  "history_end_time" : 1666167825380,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "z45838ksfw0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167772366,
  "history_end_time" : 1666167772366,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "bek8fklbp5i",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166465610,
  "history_end_time" : 1666166465610,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "6iujyemxm3z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166410288,
  "history_end_time" : 1666166419946,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "gobzi9wz7oa",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666164233098,
  "history_end_time" : 1666164233098,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lakct9ths5q",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666163607312,
  "history_end_time" : 1666163607312,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "wnnmq5xvcm4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666137012956,
  "history_end_time" : 1666137012956,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "a2km5ncdyh1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136593513,
  "history_end_time" : 1666136593513,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "nt9yfg5948x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136435836,
  "history_end_time" : 1666136435836,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "m5u5hw6zsej",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134110789,
  "history_end_time" : 1666134110789,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "inqwi7irbje",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134036943,
  "history_end_time" : 1666134036943,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "gts45qy9cx0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134008993,
  "history_end_time" : 1666134008993,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "v4x9o8ct496",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666131993221,
  "history_end_time" : 1666131993221,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "v8gsc1g75n0",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1666118288676,
  "history_end_time" : 1666118289847,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "woqz0reo2c3",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1655909884943,
  "history_end_time" : 1655909888790,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "y8a9td2h1e7",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1655908840861,
  "history_end_time" : 1655908841492,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ck6kxw07ksm",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_kenya_non_crop.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 9, in <module>\n    import pyproj\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/__init__.py\", line 81, in <module>\n    from pyproj.crs import CRS  # noqa: F401\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/__init__.py\", line 16, in <module>\n    from pyproj.crs.crs import (  # noqa: F401  pylint: disable=unused-import\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/crs.py\", line 13, in <module>\n    from pyproj._crs import (\nImportError: cannot import name 'AuthorityMatchInfo' from 'pyproj._crs' (/opt/anaconda3/lib/python3.8/site-packages/pyproj/_crs.cpython-38-darwin.so)\n",
  "history_begin_time" : 1655907443058,
  "history_end_time" : 1655907444308,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "ems3yk8sdql",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_kenya_non_crop.py\", line 2, in <module>\n    import pandas as pd\nModuleNotFoundError: No module named 'pandas'\n",
  "history_begin_time" : 1655865871502,
  "history_end_time" : 1655865871667,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "4o8kxnpn6zg",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_kenya_non_crop.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 9, in <module>\n    import pyproj\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/__init__.py\", line 81, in <module>\n    from pyproj.crs import CRS  # noqa: F401\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/__init__.py\", line 16, in <module>\n    from pyproj.crs.crs import (  # noqa: F401  pylint: disable=unused-import\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/crs.py\", line 13, in <module>\n    from pyproj._crs import (\nImportError: cannot import name 'AuthorityMatchInfo' from 'pyproj._crs' (/opt/anaconda3/lib/python3.8/site-packages/pyproj/_crs.cpython-38-darwin.so)\n",
  "history_begin_time" : 1655865097520,
  "history_end_time" : 1655865098676,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "icop2cvhumy",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347444871,
  "history_end_time" : 1647347445699,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "lyf2dl6y9p0",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347349328,
  "history_end_time" : 1647347350344,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3s82b4lg2pk",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347281726,
  "history_end_time" : 1647347283434,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "whho4n273fg",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347147769,
  "history_end_time" : 1647347150612,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "mq2q6xlzwpe",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647346821140,
  "history_end_time" : 1647346824574,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3ns6h5bdb52",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647346659289,
  "history_end_time" : 1647346662310,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "2i4kympc8qd",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138285707,
  "history_end_time" : 1646138289027,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "2yytal683wc",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138187973,
  "history_end_time" : 1646138191171,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "fk5kt1n7mtu",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138111848,
  "history_end_time" : 1646138111916,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "pz9wewkih85",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137791625,
  "history_end_time" : 1646137792670,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "e66o3ea00i8",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137695206,
  "history_end_time" : 1646137698534,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "kf4w93y36kf",
  "history_input" : "from dataclasses import dataclass\nimport pandas as pd\nfrom pathlib import Path\nimport geopandas\nfrom datetime import datetime\nimport numpy as np\n\nfrom typing import Optional\n\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_exporters_sentinel_kenya_non_crop import KenyaNonCropSentinelExporter\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass KenyaNonCropEngineer(BaseEngineer):\n\n    sentinel_dataset = KenyaNonCropSentinelExporter.dataset\n    dataset = KenyaNonCropProcessor.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        pv_kenya = data_folder / \"processed\" / KenyaNonCropProcessor.dataset / \"data.geojson\"\n        assert pv_kenya.exists(), \"Kenya Non Crop processor must be run to load labels\"\n        return geopandas.read_file(pv_kenya)\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=False,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137584549,
  "history_end_time" : 1646137587603,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "qrsdlna77op",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1655907403244,
  "history_notes" : null,
  "history_process" : "a3ucnn",
  "host_id" : "100001",
  "indicator" : "Stopped"
},]
