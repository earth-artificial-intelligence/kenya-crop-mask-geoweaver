[{
  "history_id" : "pkav61rz1op",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167825372,
  "history_end_time" : 1666167825372,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jr8ttwb9v5d",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666167772352,
  "history_end_time" : 1666167772352,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "r5wuka0xdiq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166465604,
  "history_end_time" : 1666166465604,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "v9o6gxztkjd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666166410277,
  "history_end_time" : 1666166419945,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "rggb89v4hrz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666164233092,
  "history_end_time" : 1666164233092,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "tvo8k6zg4eh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666163607303,
  "history_end_time" : 1666163607303,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "v2ddd56p8z3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666137012951,
  "history_end_time" : 1666137012951,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8psjz6fb9ex",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136593508,
  "history_end_time" : 1666136593508,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "67onf9wuguo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666136435810,
  "history_end_time" : 1666136435810,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "p4u9b6zk0oh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134110780,
  "history_end_time" : 1666134110780,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5sstxydqngl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134036931,
  "history_end_time" : 1666134036931,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "k9aqqfq47kc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666134008985,
  "history_end_time" : 1666134008985,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "99r9hc0l3hd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1666131993210,
  "history_end_time" : 1666131993210,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "v6rkn1wex48",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1666118284383,
  "history_end_time" : 1666118287654,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "hxty01e1qjd",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1655909881599,
  "history_end_time" : 1655909883928,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "zteom1mgg5k",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1655908839377,
  "history_end_time" : 1655908840929,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "i8rzepudw39",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1655907442070,
  "history_end_time" : 1655907442395,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "h3f6wzyu3t2",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_geowiki.py\", line 3, in <module>\n    import pandas as pd\nModuleNotFoundError: No module named 'pandas'\n",
  "history_begin_time" : 1655907401752,
  "history_end_time" : 1655907403173,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "gwwa00xwf7t",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_engineer_geowiki.py\", line 3, in <module>\n    import pandas as pd\nModuleNotFoundError: No module named 'pandas'\n",
  "history_begin_time" : 1655865866028,
  "history_end_time" : 1655865866190,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "qtdn7buqfyy",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1655865096739,
  "history_end_time" : 1655865100669,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "jkl66n7ff8n",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347438986,
  "history_end_time" : 1647347440169,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "zi3p69zwpyv",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347347330,
  "history_end_time" : 1647347350331,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "cp81nzoglmj",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347284069,
  "history_end_time" : 1647347284371,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "amzhkpum1hp",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647347140812,
  "history_end_time" : 1647347143345,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "twsqg51ljfx",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647346817695,
  "history_end_time" : 1647346818009,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "l6z2r0znfs4",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647346662672,
  "history_end_time" : 1647346665383,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "q32wutwo8gx",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647345856681,
  "history_end_time" : 1647345859509,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "8fzd3csozge",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647345661877,
  "history_end_time" : 1647345664730,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ojvax23l3dt",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1647340132588,
  "history_end_time" : 1647340135331,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "exrgr0h2vpq",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646147724201,
  "history_end_time" : 1646147724392,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "rj2j002s4a5",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138280534,
  "history_end_time" : 1646138284672,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "wn34ua7hd3b",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138181729,
  "history_end_time" : 1646138184963,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "zcce0e3e3tg",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646138107647,
  "history_end_time" : 1646138107878,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "zael5yt6vhl",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137792626,
  "history_end_time" : 1646137795826,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "m5nwpbl5vjx",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137695455,
  "history_end_time" : 1646137696998,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "rl2aa9cbn98",
  "history_input" : "from dataclasses import dataclass\nfrom datetime import datetime\nimport pandas as pd\nfrom pathlib import Path\nimport xarray as xr\n\nfrom typing import Optional\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_geowiki import GeoWikiSentinelExporter\nfrom src_config import PROBABILITY_THRESHOLD\nfrom src_engineer_base import BaseEngineer, DataInstance\n\n\nclass GeoWikiEngineer(BaseEngineer):\n\n    sentinel_dataset = GeoWikiSentinelExporter.dataset\n    dataset = GeoWikiExporter.dataset\n\n    @staticmethod\n    def read_labels(data_folder: Path) -> pd.DataFrame:\n        geowiki = data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def process_single_file(\n        self,\n        path_to_file: Path,\n        nan_fill: float,\n        max_nan_ratio: float,\n        add_ndvi: bool,\n        add_ndwi: bool,\n        calculate_normalizing_dict: bool,\n        start_date: datetime,\n        days_per_timestep: int,\n        is_test: bool,\n    ) -> Optional[DataInstance]:\n        r\"\"\"\n        Return a tuple of np.ndarrays of shape [n_timesteps, n_features] for\n        1) the anchor (labelled)\n        \"\"\"\n\n        da = self.load_tif(path_to_file, days_per_timestep=days_per_timestep, start_date=start_date)\n\n        # first, we find the label encompassed within the da\n\n        min_lon, min_lat = float(da.x.min()), float(da.y.min())\n        max_lon, max_lat = float(da.x.max()), float(da.y.max())\n        overlap = self.labels[\n            (\n                (self.labels.lon <= max_lon)\n                & (self.labels.lon >= min_lon)\n                & (self.labels.lat <= max_lat)\n                & (self.labels.lat >= min_lat)\n            )\n        ]\n        if len(overlap) == 0:\n            return None\n\n        label_lat = overlap.iloc[0].lat\n        label_lon = overlap.iloc[0].lon\n\n        # we turn the percentage into a fraction\n        crop_probability = overlap.iloc[0].mean_sumcrop / 100\n\n        closest_lon, _ = self.find_nearest(da.x, label_lon)\n        closest_lat, _ = self.find_nearest(da.y, label_lat)\n\n        labelled_np = da.sel(x=closest_lon).sel(y=closest_lat).values\n\n        if add_ndvi:\n            labelled_np = self.calculate_ndvi(labelled_np)\n        if add_ndwi:\n            labelled_np = self.calculate_ndwi(labelled_np)\n\n        labelled_array = self.maxed_nan_to_num(labelled_np, nan=nan_fill, max_ratio=max_nan_ratio)\n\n        if (not is_test) and calculate_normalizing_dict:\n            # we won't use the neighbouring array for now, since tile2vec is\n            # not really working\n            self.update_normalizing_values(self.normalizing_dict_interim, labelled_array)\n\n        if labelled_array is not None:\n            return DataInstance(\n                label_lat=label_lat,\n                label_lon=label_lon,\n                instance_lat=closest_lat,\n                instance_lon=closest_lon,\n                labelled_array=labelled_array,\n                is_crop=crop_probability >= PROBABILITY_THRESHOLD,\n                dataset=self.dataset,\n            )\n        else:\n            return None\n",
  "history_output" : "",
  "history_begin_time" : 1646137581323,
  "history_end_time" : 1646137581433,
  "history_notes" : null,
  "history_process" : "rus783",
  "host_id" : "100001",
  "indicator" : "Done"
},]
