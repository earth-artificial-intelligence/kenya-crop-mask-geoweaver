[{
  "history_id" : "k76sgo66nqz",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1666118345109,
  "history_end_time" : 1666118346133,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "r8okl4158ol",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1655909926501,
  "history_end_time" : 1655909927906,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "o6mj8670naf",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_models_data.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 227, in <module>\n    PYPROJ_LT_3 = LooseVersion(pyproj.__version__) < LooseVersion(\"3\")\nAttributeError: module 'pyproj' has no attribute '__version__'\n",
  "history_begin_time" : 1655908836018,
  "history_end_time" : 1655908836950,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "pdo8phh9ihk",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_models_data.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 9, in <module>\n    import pyproj\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/__init__.py\", line 81, in <module>\n    from pyproj.crs import CRS  # noqa: F401\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/__init__.py\", line 16, in <module>\n    from pyproj.crs.crs import (  # noqa: F401  pylint: disable=unused-import\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/crs.py\", line 13, in <module>\n    from pyproj._crs import (\nImportError: cannot import name 'AuthorityMatchInfo' from 'pyproj._crs' (/opt/anaconda3/lib/python3.8/site-packages/pyproj/_crs.cpython-38-darwin.so)\n",
  "history_begin_time" : 1655907451267,
  "history_end_time" : 1655907452035,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "vdcrz3cq62l",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : 1655907402969,
  "history_end_time" : 1655907403255,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "6qopjsaw8bd",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_models_data.py\", line 2, in <module>\n    import numpy as np\nModuleNotFoundError: No module named 'numpy'\n",
  "history_begin_time" : 1655865866488,
  "history_end_time" : 1655865866660,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "wi6h5rtdmqi",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "Traceback (most recent call last):\n  File \"src_models_data.py\", line 4, in <module>\n    import geopandas\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/__init__.py\", line 1, in <module>\n    from geopandas._config import options  # noqa\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 109, in <module>\n    default_value=_default_use_pygeos(),\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_config.py\", line 95, in _default_use_pygeos\n    import geopandas._compat as compat\n  File \"/opt/anaconda3/lib/python3.8/site-packages/geopandas/_compat.py\", line 9, in <module>\n    import pyproj\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/__init__.py\", line 81, in <module>\n    from pyproj.crs import CRS  # noqa: F401\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/__init__.py\", line 16, in <module>\n    from pyproj.crs.crs import (  # noqa: F401  pylint: disable=unused-import\n  File \"/opt/anaconda3/lib/python3.8/site-packages/pyproj/crs/crs.py\", line 13, in <module>\n    from pyproj._crs import (\nImportError: cannot import name 'AuthorityMatchInfo' from 'pyproj._crs' (/opt/anaconda3/lib/python3.8/site-packages/pyproj/_crs.cpython-38-darwin.so)\n",
  "history_begin_time" : 1655865102149,
  "history_end_time" : 1655865103044,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "bt0q7iv827r",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1647347443873,
  "history_end_time" : 1647347444310,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "nle5byxlm7k",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1647347372095,
  "history_end_time" : 1647347373247,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ujqcwhnz6x9",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1647347285426,
  "history_end_time" : 1647347286560,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "62r4o7kil4s",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1647347141693,
  "history_end_time" : 1647347142692,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "h5eibke1f2d",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1647346841988,
  "history_end_time" : 1647346842667,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "cjin5jql6wg",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1647346683282,
  "history_end_time" : 1647346684371,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "xn97g6b68cw",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1646138301374,
  "history_end_time" : 1646138302525,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "yjvisb6erei",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1646138202250,
  "history_end_time" : 1646138202549,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "2egk1c17ww3",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1646138109849,
  "history_end_time" : 1646138111078,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "gxwy6mp7271",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1646137795906,
  "history_end_time" : 1646137796743,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "l60fgaq9wnq",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1646137707936,
  "history_end_time" : 1646137709193,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "u631yaan346",
  "history_input" : "from pathlib import Path\nimport numpy as np\nimport pickle\nimport geopandas\nimport random\nimport math\n\nfrom tqdm import tqdm\n\nimport torch\nfrom torch.utils.data import Dataset\n\nfrom src_exporters_geowiki import GeoWikiExporter\nfrom src_exporters_sentinel_cloudfree_constants import BANDS\nfrom src_processors_pv_kenya import KenyaPVProcessor\nfrom src_processors_kenya_non_crop import KenyaNonCropProcessor\nfrom src_processors_geowiki import GeoWikiProcessor\n\nfrom typing import cast, Tuple, Optional, List, Dict, Sequence, Union\n\n\nclass CropDataset(Dataset):\n\n    bands_to_remove = [\"B1\", \"B10\"]\n\n    def __init__(\n        self,\n        data_folder: Path,\n        subset: str,\n        remove_b1_b10: bool,\n        include_geowiki: bool,\n        cache: bool,\n        upsample: bool,\n        noise_factor: bool,\n        normalizing_dict: Optional[Dict] = None,\n    ) -> None:\n\n        self.include_geowiki = include_geowiki\n        self.upsample = upsample\n\n        self.data_folder = data_folder\n        self.features_dir = data_folder / \"features\"\n\n        assert subset in [\"training\", \"validation\", \"testing\"]\n        self.subset_name = subset\n\n        self.remove_b1_b10 = remove_b1_b10\n\n        self.x: Optional[torch.Tensor] = None\n        self.y: Optional[torch.Tensor] = None\n        self.weights: Optional[torch.Tensor] = None\n\n        # this is kept at False in case caching = True. It should be\n        # changed to the input noise argument at the end of the\n        # init function\n        self.noise_factor = 0\n\n        files_and_nds: List[Tuple] = []\n        for dataset in [\n            KenyaPVProcessor.dataset,\n            KenyaNonCropProcessor.dataset,\n            GeoWikiExporter.dataset,\n        ]:\n            files_and_nds.append(\n                self.load_files_and_normalizing_dicts(\n                    self.data_folder / \"features\" / dataset, self.subset_name,\n                )\n            )\n\n        if normalizing_dict is not None:\n            self.normalizing_dict: Optional[Dict] = normalizing_dict\n        else:\n            # if no normalizing dict was passed to the consturctor,\n            # then we want to make our own\n            self.normalizing_dict = self.adjust_normalizing_dict(\n                [(len(x[0]), x[1]) for x in files_and_nds]\n            )\n\n        pickle_files: List[Path] = []\n        for files, _ in files_and_nds:\n            pickle_files.extend(files)\n        self.pickle_files = pickle_files\n\n        self.cache = False\n\n        self.class_instances: List = []\n        if upsample:\n            instances_per_class = self.instances_per_class\n            max_instances_in_class = max(instances_per_class)\n\n            new_pickle_files: List[Path] = []\n\n            for idx, num_instances in enumerate(instances_per_class):\n                if num_instances > 0:\n                    new_pickle_files.extend(self.upsample_class(idx, max_instances_in_class))\n            self.pickle_files.extend(new_pickle_files)\n\n        if cache:\n            self.x, self.y, self.weights = self.to_array()\n            self.cache = cache\n        # we only save the noise attribute after the arrays have been cached, to\n        # ensure the saved arrays are the noiseless ones\n        self.noise_factor = noise_factor\n\n    @staticmethod\n    def load_files_and_normalizing_dicts(\n        features_dir: Path, subset_name: str, file_suffix: str = \"pkl\"\n    ) -> Tuple[List[Path], Optional[Dict[str, np.ndarray]]]:\n        pickle_files = list((features_dir / subset_name).glob(f\"*.{file_suffix}\"))\n\n        # try loading the normalizing dict. By default, if it exists we will use it\n        if (features_dir / \"normalizing_dict.pkl\").exists():\n            with (features_dir / \"normalizing_dict.pkl\").open(\"rb\") as f:\n                normalizing_dict = pickle.load(f)\n        else:\n            normalizing_dict = None\n\n        return pickle_files, normalizing_dict\n\n    def _normalize(self, array: np.ndarray) -> np.ndarray:\n        if self.normalizing_dict is None:\n            return array\n        else:\n            return (array - self.normalizing_dict[\"mean\"]) / self.normalizing_dict[\"std\"]\n\n    def __len__(self) -> int:\n        return len(self.pickle_files)\n\n    def to_array(self) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        if self.x is not None:\n            assert self.y is not None\n            assert self.weights is not None\n            return self.x, self.y, self.weights\n        else:\n            x_list: List[torch.Tensor] = []\n            y_list: List[torch.Tensor] = []\n            weight_list: List[torch.Tensor] = []\n            print(\"Loading data into memory\")\n            for i in tqdm(range(len(self))):\n                x, y, weight = self[i]\n                x_list.append(x)\n                y_list.append(y)\n                weight_list.append(weight)\n\n            return torch.stack(x_list), torch.stack(y_list), torch.stack(weight_list)\n\n    @property\n    def num_input_features(self) -> int:\n\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n\n        output = self[0]\n        if isinstance(output, tuple):\n            return output[0].shape[1]\n        else:\n            return output.shape[1]\n\n    @property\n    def num_timesteps(self) -> int:\n        # assumes the first value in the tuple is x\n        assert len(self.pickle_files) > 0, \"No files to load!\"\n        output_tuple = self[0]\n        return output_tuple[0].shape[0]\n\n    @staticmethod\n    def adjust_normalizing_dict(\n        dicts: Sequence[Tuple[int, Optional[Dict[str, np.ndarray]]]]\n    ) -> Optional[Dict[str, np.ndarray]]:\n\n        for _, single_dict in dicts:\n            if single_dict is None:\n                return None\n\n        dicts = cast(Sequence[Tuple[int, Dict[str, np.ndarray]]], dicts)\n\n        new_total = sum([x[0] for x in dicts])\n\n        new_mean = sum([single_dict[\"mean\"] * length for length, single_dict in dicts]) / new_total\n\n        new_variance = (\n            sum(\n                [\n                    (single_dict[\"std\"] ** 2 + (single_dict[\"mean\"] - new_mean) ** 2) * length\n                    for length, single_dict in dicts\n                ]\n            )\n            / new_total\n        )\n\n        return {\"mean\": new_mean, \"std\": np.sqrt(new_variance)}\n\n    def remove_bands(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"This nested function is so that\n        _remove_bands can be called from an unitialized\n        dataset, speeding things up at inference while still\n        keeping the convenience of not having to check if remove\n        bands is true all the time.\n        \"\"\"\n\n        if self.remove_bands:\n            return self._remove_bands(x)\n        else:\n            return x\n\n    @classmethod\n    def _remove_bands(cls, x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Expects the input to be of shape [timesteps, bands]\n        \"\"\"\n        indices_to_remove: List[int] = []\n        for band in cls.bands_to_remove:\n            indices_to_remove.append(BANDS.index(band))\n\n        bands_index = 1 if len(x.shape) == 2 else 2\n        indices_to_keep = [i for i in range(x.shape[bands_index]) if i not in indices_to_remove]\n        if len(x.shape) == 2:\n            # timesteps, bands\n            return x[:, indices_to_keep]\n        else:\n            # batches, timesteps, bands\n            return x[:, :, indices_to_keep]\n\n    def upsample_class(self, class_idx: int, max_instances: int) -> List[Path]:\n        \"\"\"Given a class to upsample and the maximum number of classes,\n        update self.pickle_files to reflect the new number of classes\n        \"\"\"\n        class_files: List[Path] = []\n        for idx, filepath in enumerate(self.pickle_files):\n            _, class_int, is_global = self[idx]\n            if is_global == 0:\n                if class_int == class_idx:\n                    class_files.append(filepath)\n\n        multiplier = max_instances / len(class_files)\n\n        # we will return files which need to be *added* to pickle files\n        # multiplier will definitely be >= 1\n        fraction_multiplier, int_multiplier = math.modf(multiplier - 1)\n\n        new_files = random.sample(class_files, int(fraction_multiplier * len(class_files)))\n        new_files += class_files * int(int_multiplier)\n        return new_files\n\n    @property\n    def num_output_classes(self) -> Union[int, Tuple[int, int]]:\n\n        if self.include_geowiki:\n            # multi headed\n            return 1, 1\n        else:\n            return 1\n\n    def filter_min_occurences(\n        self, files: List[Path], min_occurences: int, ignore_intercropped: bool\n    ) -> Tuple[List[Path], List[str]]:\n\n        org_data = geopandas.read_file(\n            self.data_folder / \"processed\" / KenyaPVProcessor.dataset / \"data.geojson\"\n        )\n\n        counts = org_data.crop_type.value_counts().to_dict()\n\n        crops_to_ignore = [crop for crop, count in counts.items() if count < min_occurences]\n\n        if ignore_intercropped:\n            crops_to_ignore.extend([crop for crop, count in counts.items() if \"intercrop\" in crop])\n            crops_to_ignore = list(set(crops_to_ignore))\n\n        output_files: List[Path] = []\n        for target_file in files:\n            with target_file.open(\"rb\") as f:\n                target_datainstance = pickle.load(f)\n            if target_datainstance.crop_label in crops_to_ignore:\n                continue\n            else:\n                output_files.append(target_file)\n        return output_files, crops_to_ignore\n\n    @property\n    def instances_per_class(self) -> List[int]:\n\n        num_output_classes = self.num_output_classes\n        num_local_output_classes = (\n            num_output_classes[1] if isinstance(num_output_classes, tuple) else num_output_classes\n        )\n        if len(self.class_instances) == 0:\n            # we set a minimum number of output classes since if its 1,\n            # its really 2 (binary)\n            instances_per_class = [0] * max(num_local_output_classes, 2)\n            for i in range(len(self)):\n                _, class_int, is_global = self[i]\n                if is_global == 0:\n                    instances_per_class[int(class_int)] += 1\n            self.class_instances = instances_per_class\n        return self.class_instances\n\n    def __getitem__(self, index: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n\n        if (self.cache) & (self.x is not None):\n            # if we upsample, the caching might not have happened yet\n            return (\n                cast(torch.Tensor, self.x)[index],\n                cast(torch.Tensor, self.y)[index],\n                cast(torch.Tensor, self.weights)[index],\n            )\n\n        target_file = self.pickle_files[index]\n\n        # first, we load up the target file\n        with target_file.open(\"rb\") as f:\n            target_datainstance = pickle.load(f)\n\n        is_global: float = 0.0\n\n        crop_int = int(target_datainstance.is_crop)\n        is_global = 1 if target_datainstance.dataset == GeoWikiProcessor.dataset else 0\n\n        x = self.remove_bands(x=self._normalize(target_datainstance.labelled_array))\n\n        return (\n            torch.from_numpy(x).float(),\n            torch.tensor(crop_int).float(),\n            torch.tensor(is_global).float(),\n        )\n",
  "history_output" : "",
  "history_begin_time" : 1646137596770,
  "history_end_time" : 1646137598071,
  "history_notes" : null,
  "history_process" : "t2liev",
  "host_id" : "100001",
  "indicator" : "Done"
},]
