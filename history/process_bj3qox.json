[{
  "history_id" : "oiko4oh4auc",
  "history_input" : "import sys\nimport subprocess\nimport pkg_resources\n\n# Required packages to run this process.\nrequired = {'pandas', 'numpy', 'xarray', 'pytorch-lightning', 'tqdm', 'earthengine-api'}\ninstalled = {pkg.key for pkg in pkg_resources.working_set}\nmissing = required - installed\n\nif missing:\n    print(\"Packages missing and will be installed: \", missing)\n    python = sys.executable\n    subprocess.check_call(\n        [python, '-m', 'pip', 'install', *missing], stdout=subprocess.DEVNULL)\n\n################################\n#  END OF PACKAGES VALIDATION  #\n################################\n\n'''\nThis process requires Google Earth Engine creds on machine running it.\n\nThis process requires Python 3.7+\n\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport math\nimport ee\n\n####################\n#   constants.py   #\n####################\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n###########################\n#   END of constants.py   #\n###########################\n\n\n\n####################\n#   src/utils.py   #\n####################\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n      \ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n###########################\n#   END of src/utils.py   #\n###########################\n\n\n\n\n\n################\n#   utils.py   #\n################\n@dataclass\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n#######################\n#   END of utils.py   #\n#######################\n  \n  \n  \n\n\n##########################\n#   cloudfree/utils.py   #\n##########################\ndef combine_bands(current, previous):\n    # Transforms an Image Collection with 1 band per Image into a single Image with items as bands\n    # Author: Jamie Vleeshouwer\n\n    # Rename the band\n    previous = ee.Image(previous)\n    current = current.select(BANDS)\n    # Append it to the result (Note: only return current item on first element/iteration)\n    return ee.Algorithms.If(\n        ee.Algorithms.IsEqual(previous, None), current, previous.addBands(ee.Image(current)),\n    )\n\n\ndef export(\n    image: ee.Image, region: ee.Geometry, filename: str, drive_folder: str, monitor: bool = False,\n) -> ee.batch.Export:\n\n    task = ee.batch.Export.image(\n        image.clip(region),\n        filename,\n        {\"scale\": 10, \"region\": region, \"maxPixels\": 1e13, \"driveFolder\": drive_folder},\n    )\n\n    try:\n        task.start()\n    except ee.ee_exception.EEException as e:\n        print(f\"Task not started! Got exception {e}\")\n        return task\n\n    if monitor:\n        monitor_task(task)\n\n    return task\n\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\n\ndef monitor_task(task: ee.batch.Export) -> None:\n\n    while task.status()[\"state\"] in [\"READY\", \"RUNNING\"]:\n        print(task.status())\n        # print(f\"Running: {task.status()['state']}\")\n\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n#################################\n#   END of cloudfree/utils.py   #\n#################################\n  \n  \n  \n  \n####################\n#   cloudfree.py   #\n####################\ndef calcCloudStats(img):\n    imgPoly = ee.Algorithms.GeometryConstructors.Polygon(\n        ee.Geometry(img.get(\"system:footprint\")).coordinates()\n    )\n\n    roi = ee.Geometry(img.get(\"ROI\"))\n\n    intersection = roi.intersection(imgPoly, ee.ErrorMargin(0.5))\n    cloudMask = img.select([\"cloudScore\"]).gt(cloudThresh).clip(roi).rename(\"cloudMask\")\n\n    cloudAreaImg = cloudMask.multiply(ee.Image.pixelArea())\n\n    stats = cloudAreaImg.reduceRegion(\n        **{\"reducer\": ee.Reducer.sum(), \"geometry\": roi, \"scale\": 10, \"maxPixels\": 1e12}\n    )\n\n    cloudPercent = ee.Number(stats.get(\"cloudMask\")).divide(imgPoly.area()).multiply(100)\n    coveragePercent = ee.Number(intersection.area()).divide(roi.area()).multiply(100)\n    cloudPercentROI = ee.Number(stats.get(\"cloudMask\")).divide(roi.area()).multiply(100)\n\n    img = img.set(\"CLOUDY_PERCENTAGE\", cloudPercent)\n    img = img.set(\"ROI_COVERAGE_PERCENT\", coveragePercent)\n    img = img.set(\"CLOUDY_PERCENTAGE_ROI\", cloudPercentROI)\n\n    return img\n\n\ndef computeQualityScore(img):\n    score = img.select([\"cloudScore\"]).max(img.select([\"shadowScore\"]))\n\n    score = score.reproject(\"EPSG:4326\", None, 20).reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    score = score.multiply(-1)\n\n    return img.addBands(score.rename(\"cloudShadowScore\"))\n\n\ndef computeS2CloudScore(img):\n    toa = img.select(\n        [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B9\", \"B10\", \"B11\", \"B12\",]\n    ).divide(10000)\n\n    toa = toa.addBands(img.select([\"QA60\"]))\n\n    # ['QA60', 'B1','B2',    'B3',    'B4',   'B5','B6','B7', 'B8','  B8A',\n    #  'B9',          'B10', 'B11','B12']\n    # ['QA60','cb', 'blue', 'green', 'red', 're1','re2','re3','nir', 'nir2',\n    #  'waterVapor', 'cirrus','swir1', 'swir2']);\n\n    # Compute several indicators of cloudyness and take the minimum of them.\n    score = ee.Image(1)\n\n    # Clouds are reasonably bright in the blue and cirrus bands.\n    score = score.min(rescale(toa, \"img.B2\", [0.1, 0.5]))\n    score = score.min(rescale(toa, \"img.B1\", [0.1, 0.3]))\n    score = score.min(rescale(toa, \"img.B1 + img.B10\", [0.15, 0.2]))\n\n    # Clouds are reasonably bright in all visible bands.\n    score = score.min(rescale(toa, \"img.B4 + img.B3 + img.B2\", [0.2, 0.8]))\n\n    # Clouds are moist\n    ndmi = img.normalizedDifference([\"B8\", \"B11\"])\n    score = score.min(rescale(ndmi, \"img\", [-0.1, 0.1]))\n\n    # However, clouds are not snow.\n    ndsi = img.normalizedDifference([\"B3\", \"B11\"])\n    score = score.min(rescale(ndsi, \"img\", [0.8, 0.6]))\n\n    # Clip the lower end of the score\n    score = score.max(ee.Image(0.001))\n\n    # score = score.multiply(dilated)\n    score = score.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    return img.addBands(score.rename(\"cloudScore\"))\n\n\ndef projectShadows(image):\n    meanAzimuth = image.get(\"MEAN_SOLAR_AZIMUTH_ANGLE\")\n    meanZenith = image.get(\"MEAN_SOLAR_ZENITH_ANGLE\")\n\n    cloudMask = image.select([\"cloudScore\"]).gt(cloudThresh)\n\n    # Find dark pixels\n    darkPixelsImg = image.select([\"B8\", \"B11\", \"B12\"]).divide(10000).reduce(ee.Reducer.sum())\n\n    ndvi = image.normalizedDifference([\"B8\", \"B4\"])\n    waterMask = ndvi.lt(ndviThresh)\n\n    darkPixels = darkPixelsImg.lt(irSumThresh)\n\n    # Get the mask of pixels which might be shadows excluding water\n    darkPixelMask = darkPixels.And(waterMask.Not())\n    darkPixelMask = darkPixelMask.And(cloudMask.Not())\n\n    # Find where cloud shadows should be based on solar geometry\n    # Convert to radians\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\n    zenR = ee.Number(meanZenith).multiply(math.pi).divide(180.0)\n\n    # Find the shadows\n    def getShadows(cloudHeight):\n        cloudHeight = ee.Number(cloudHeight)\n\n        shadowCastedDistance = zenR.tan().multiply(cloudHeight)  # Distance shadow is cast\n        x = azR.sin().multiply(shadowCastedDistance).multiply(-1)  # /X distance of shadow\n        y = azR.cos().multiply(shadowCastedDistance).multiply(-1)  # Y distance of shadow\n        return image.select([\"cloudScore\"]).displace(\n            ee.Image.constant(x).addBands(ee.Image.constant(y))\n        )\n\n    shadows = ee.List(cloudHeights).map(getShadows)\n    shadowMasks = ee.ImageCollection.fromImages(shadows)\n    shadowMask = shadowMasks.mean()\n\n    # Create shadow mask\n    shadowMask = dilatedErossion(shadowMask.multiply(darkPixelMask))\n\n    shadowScore = shadowMask.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.max(), \"kernel\": ee.Kernel.square(1)}\n    )\n\n    image = image.addBands(shadowScore.rename([\"shadowScore\"]))\n\n    return image\n\n\ndef dilatedErossion(score):\n    # Perform opening on the cloud scores\n    score = (\n        score.reproject(\"EPSG:4326\", None, 20)\n        .focal_min(**{\"radius\": erodePixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .focal_max(**{\"radius\": dilationPixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .reproject(\"EPSG:4326\", None, 20)\n    )\n\n    return score\n\n\ndef mergeCollection(imgC):\n    # Select the best images, which are below the cloud free threshold, sort them in reverse order\n    # (worst on top) for mosaicing\n    best = imgC.filterMetadata(\"CLOUDY_PERCENTAGE\", \"less_than\", cloudFreeKeepThresh).sort(\n        \"CLOUDY_PERCENTAGE\", False\n    )\n    filtered = imgC.qualityMosaic(\"cloudShadowScore\")\n\n    # Add the quality mosaic to fill in any missing areas of the ROI which aren't covered by good\n    # images\n    newC = ee.ImageCollection.fromImages([filtered, best.mosaic()])\n\n    return ee.Image(newC.mosaic())\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\n###########################\n#   END of cloudfree.py   #\n###########################\n  \n  \n  \n\n#########################\n#   exporters/base.py   #\n#########################\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n################################\n#   END of exporters/base.py   #\n################################\n\n\n\n\n##################################\n#   exporters/sentinel/base.py   #\n##################################\nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(combine_bands))\n\n        # and finally, export the image\n        export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n#########################################\n#   END of exporters/sentinel/base.py   #\n#########################################\n\n\n\n\n\n############################\n#   exporters/geowiki.py   #\n############################\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n###################################\n#   END of exporters/geowiki.py   #\n###################################\n\n\n\n\n#####################################\n#   exporters/sentinel/geowiki.py   #\n#####################################\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n############################################\n#   END of exporters/sentinel/geowiki.py   #\n############################################\n\n\n\n\n##############################\n#   src/processors/base.py   #\n##############################\nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n#####################################\n#   END of src/processors/base.py   #\n#####################################\n        \n  \n  \n  \n#################################\n#   src/processors/geowiki.py   #\n#################################\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n########################################\n#   END of src/processors/geowiki.py   #\n########################################\n\n\n\n##########################\n#   scripts/process.py   #\n##########################\ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n#################################\n#   END of scripts/process.py   #\n#################################\n\n\n\n#########################\n#   scripts/export.py   #\n#########################\ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n################################\n#   END of scripts/export.py   #\n################################\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1654.41it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 1 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 2 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 3 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 4 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 5 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 6 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 7 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 8 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 9 from aggregated images between 2017-03-28 and 2017-03-29\n",
  "history_begin_time" : 1644877968525,
  "history_end_time" : 1644877981700,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "23yG0D3EANwB",
  "history_input" : "import sys\nimport subprocess\nimport pkg_resources\n\n# Required packages to run this process.\nrequired = {'pandas', 'numpy', 'xarray', 'pytorch-lightning', 'tqdm', 'earthengine-api'}\ninstalled = {pkg.key for pkg in pkg_resources.working_set}\nmissing = required - installed\n\nif missing:\n    print(\"Packages missing and will be installed: \", missing)\n    python = sys.executable\n    subprocess.check_call(\n        [python, '-m', 'pip', 'install', *missing], stdout=subprocess.DEVNULL)\n\n################################\n#  END OF PACKAGES VALIDATION  #\n################################\n\n'''\nThis process requires Google Earth Engine creds on machine running it.\n\nThis process requires Python 3.7+\n\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport math\nimport ee\n\n####################\n#   constants.py   #\n####################\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n###########################\n#   END of constants.py   #\n###########################\n\n\n\n####################\n#   src/utils.py   #\n####################\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n      \ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n###########################\n#   END of src/utils.py   #\n###########################\n\n\n\n\n\n################\n#   utils.py   #\n################\n@dataclass\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n#######################\n#   END of utils.py   #\n#######################\n  \n  \n  \n\n\n##########################\n#   cloudfree/utils.py   #\n##########################\ndef combine_bands(current, previous):\n    # Transforms an Image Collection with 1 band per Image into a single Image with items as bands\n    # Author: Jamie Vleeshouwer\n\n    # Rename the band\n    previous = ee.Image(previous)\n    current = current.select(BANDS)\n    # Append it to the result (Note: only return current item on first element/iteration)\n    return ee.Algorithms.If(\n        ee.Algorithms.IsEqual(previous, None), current, previous.addBands(ee.Image(current)),\n    )\n\n\ndef export(\n    image: ee.Image, region: ee.Geometry, filename: str, drive_folder: str, monitor: bool = False,\n) -> ee.batch.Export:\n\n    task = ee.batch.Export.image(\n        image.clip(region),\n        filename,\n        {\"scale\": 10, \"region\": region, \"maxPixels\": 1e13, \"driveFolder\": drive_folder},\n    )\n\n    try:\n        task.start()\n    except ee.ee_exception.EEException as e:\n        print(f\"Task not started! Got exception {e}\")\n        return task\n\n    if monitor:\n        monitor_task(task)\n\n    return task\n\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\n\ndef monitor_task(task: ee.batch.Export) -> None:\n\n    while task.status()[\"state\"] in [\"READY\", \"RUNNING\"]:\n        print(task.status())\n        # print(f\"Running: {task.status()['state']}\")\n\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n#################################\n#   END of cloudfree/utils.py   #\n#################################\n  \n  \n  \n  \n####################\n#   cloudfree.py   #\n####################\ndef calcCloudStats(img):\n    imgPoly = ee.Algorithms.GeometryConstructors.Polygon(\n        ee.Geometry(img.get(\"system:footprint\")).coordinates()\n    )\n\n    roi = ee.Geometry(img.get(\"ROI\"))\n\n    intersection = roi.intersection(imgPoly, ee.ErrorMargin(0.5))\n    cloudMask = img.select([\"cloudScore\"]).gt(cloudThresh).clip(roi).rename(\"cloudMask\")\n\n    cloudAreaImg = cloudMask.multiply(ee.Image.pixelArea())\n\n    stats = cloudAreaImg.reduceRegion(\n        **{\"reducer\": ee.Reducer.sum(), \"geometry\": roi, \"scale\": 10, \"maxPixels\": 1e12}\n    )\n\n    cloudPercent = ee.Number(stats.get(\"cloudMask\")).divide(imgPoly.area()).multiply(100)\n    coveragePercent = ee.Number(intersection.area()).divide(roi.area()).multiply(100)\n    cloudPercentROI = ee.Number(stats.get(\"cloudMask\")).divide(roi.area()).multiply(100)\n\n    img = img.set(\"CLOUDY_PERCENTAGE\", cloudPercent)\n    img = img.set(\"ROI_COVERAGE_PERCENT\", coveragePercent)\n    img = img.set(\"CLOUDY_PERCENTAGE_ROI\", cloudPercentROI)\n\n    return img\n\n\ndef computeQualityScore(img):\n    score = img.select([\"cloudScore\"]).max(img.select([\"shadowScore\"]))\n\n    score = score.reproject(\"EPSG:4326\", None, 20).reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    score = score.multiply(-1)\n\n    return img.addBands(score.rename(\"cloudShadowScore\"))\n\n\ndef computeS2CloudScore(img):\n    toa = img.select(\n        [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B9\", \"B10\", \"B11\", \"B12\",]\n    ).divide(10000)\n\n    toa = toa.addBands(img.select([\"QA60\"]))\n\n    # ['QA60', 'B1','B2',    'B3',    'B4',   'B5','B6','B7', 'B8','  B8A',\n    #  'B9',          'B10', 'B11','B12']\n    # ['QA60','cb', 'blue', 'green', 'red', 're1','re2','re3','nir', 'nir2',\n    #  'waterVapor', 'cirrus','swir1', 'swir2']);\n\n    # Compute several indicators of cloudyness and take the minimum of them.\n    score = ee.Image(1)\n\n    # Clouds are reasonably bright in the blue and cirrus bands.\n    score = score.min(rescale(toa, \"img.B2\", [0.1, 0.5]))\n    score = score.min(rescale(toa, \"img.B1\", [0.1, 0.3]))\n    score = score.min(rescale(toa, \"img.B1 + img.B10\", [0.15, 0.2]))\n\n    # Clouds are reasonably bright in all visible bands.\n    score = score.min(rescale(toa, \"img.B4 + img.B3 + img.B2\", [0.2, 0.8]))\n\n    # Clouds are moist\n    ndmi = img.normalizedDifference([\"B8\", \"B11\"])\n    score = score.min(rescale(ndmi, \"img\", [-0.1, 0.1]))\n\n    # However, clouds are not snow.\n    ndsi = img.normalizedDifference([\"B3\", \"B11\"])\n    score = score.min(rescale(ndsi, \"img\", [0.8, 0.6]))\n\n    # Clip the lower end of the score\n    score = score.max(ee.Image(0.001))\n\n    # score = score.multiply(dilated)\n    score = score.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    return img.addBands(score.rename(\"cloudScore\"))\n\n\ndef projectShadows(image):\n    meanAzimuth = image.get(\"MEAN_SOLAR_AZIMUTH_ANGLE\")\n    meanZenith = image.get(\"MEAN_SOLAR_ZENITH_ANGLE\")\n\n    cloudMask = image.select([\"cloudScore\"]).gt(cloudThresh)\n\n    # Find dark pixels\n    darkPixelsImg = image.select([\"B8\", \"B11\", \"B12\"]).divide(10000).reduce(ee.Reducer.sum())\n\n    ndvi = image.normalizedDifference([\"B8\", \"B4\"])\n    waterMask = ndvi.lt(ndviThresh)\n\n    darkPixels = darkPixelsImg.lt(irSumThresh)\n\n    # Get the mask of pixels which might be shadows excluding water\n    darkPixelMask = darkPixels.And(waterMask.Not())\n    darkPixelMask = darkPixelMask.And(cloudMask.Not())\n\n    # Find where cloud shadows should be based on solar geometry\n    # Convert to radians\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\n    zenR = ee.Number(meanZenith).multiply(math.pi).divide(180.0)\n\n    # Find the shadows\n    def getShadows(cloudHeight):\n        cloudHeight = ee.Number(cloudHeight)\n\n        shadowCastedDistance = zenR.tan().multiply(cloudHeight)  # Distance shadow is cast\n        x = azR.sin().multiply(shadowCastedDistance).multiply(-1)  # /X distance of shadow\n        y = azR.cos().multiply(shadowCastedDistance).multiply(-1)  # Y distance of shadow\n        return image.select([\"cloudScore\"]).displace(\n            ee.Image.constant(x).addBands(ee.Image.constant(y))\n        )\n\n    shadows = ee.List(cloudHeights).map(getShadows)\n    shadowMasks = ee.ImageCollection.fromImages(shadows)\n    shadowMask = shadowMasks.mean()\n\n    # Create shadow mask\n    shadowMask = dilatedErossion(shadowMask.multiply(darkPixelMask))\n\n    shadowScore = shadowMask.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.max(), \"kernel\": ee.Kernel.square(1)}\n    )\n\n    image = image.addBands(shadowScore.rename([\"shadowScore\"]))\n\n    return image\n\n\ndef dilatedErossion(score):\n    # Perform opening on the cloud scores\n    score = (\n        score.reproject(\"EPSG:4326\", None, 20)\n        .focal_min(**{\"radius\": erodePixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .focal_max(**{\"radius\": dilationPixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .reproject(\"EPSG:4326\", None, 20)\n    )\n\n    return score\n\n\ndef mergeCollection(imgC):\n    # Select the best images, which are below the cloud free threshold, sort them in reverse order\n    # (worst on top) for mosaicing\n    best = imgC.filterMetadata(\"CLOUDY_PERCENTAGE\", \"less_than\", cloudFreeKeepThresh).sort(\n        \"CLOUDY_PERCENTAGE\", False\n    )\n    filtered = imgC.qualityMosaic(\"cloudShadowScore\")\n\n    # Add the quality mosaic to fill in any missing areas of the ROI which aren't covered by good\n    # images\n    newC = ee.ImageCollection.fromImages([filtered, best.mosaic()])\n\n    return ee.Image(newC.mosaic())\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\n###########################\n#   END of cloudfree.py   #\n###########################\n  \n  \n  \n\n#########################\n#   exporters/base.py   #\n#########################\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n################################\n#   END of exporters/base.py   #\n################################\n\n\n\n\n##################################\n#   exporters/sentinel/base.py   #\n##################################\nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(combine_bands))\n\n        # and finally, export the image\n        export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n#########################################\n#   END of exporters/sentinel/base.py   #\n#########################################\n\n\n\n\n\n############################\n#   exporters/geowiki.py   #\n############################\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n###################################\n#   END of exporters/geowiki.py   #\n###################################\n\n\n\n\n#####################################\n#   exporters/sentinel/geowiki.py   #\n#####################################\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n############################################\n#   END of exporters/sentinel/geowiki.py   #\n############################################\n\n\n\n\n##############################\n#   src/processors/base.py   #\n##############################\nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n#####################################\n#   END of src/processors/base.py   #\n#####################################\n        \n  \n  \n  \n#################################\n#   src/processors/geowiki.py   #\n#################################\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n########################################\n#   END of src/processors/geowiki.py   #\n########################################\n\n\n\n##########################\n#   scripts/process.py   #\n##########################\ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n#################################\n#   END of scripts/process.py   #\n#################################\n\n\n\n#########################\n#   scripts/export.py   #\n#########################\ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n################################\n#   END of scripts/export.py   #\n################################\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1428.85it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 1 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 2 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 3 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 4 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 5 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 6 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 7 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 8 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 9 from aggregated images between 2017-03-28 and 2017-03-29\n",
  "history_begin_time" : 1644877225018,
  "history_end_time" : 1644877238561,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "CIlPYSdfB6ZK",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport math\nimport ee\n\n####################\n#   constants.py   #\n####################\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n###########################\n#   END of constants.py   #\n###########################\n\n\n\n####################\n#   src/utils.py   #\n####################\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n      \ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n###########################\n#   END of src/utils.py   #\n###########################\n\n\n\n\n\n################\n#   utils.py   #\n################\n@dataclass\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n#######################\n#   END of utils.py   #\n#######################\n  \n  \n  \n\n\n##########################\n#   cloudfree/utils.py   #\n##########################\ndef combine_bands(current, previous):\n    # Transforms an Image Collection with 1 band per Image into a single Image with items as bands\n    # Author: Jamie Vleeshouwer\n\n    # Rename the band\n    previous = ee.Image(previous)\n    current = current.select(BANDS)\n    # Append it to the result (Note: only return current item on first element/iteration)\n    return ee.Algorithms.If(\n        ee.Algorithms.IsEqual(previous, None), current, previous.addBands(ee.Image(current)),\n    )\n\n\ndef export(\n    image: ee.Image, region: ee.Geometry, filename: str, drive_folder: str, monitor: bool = False,\n) -> ee.batch.Export:\n\n    task = ee.batch.Export.image(\n        image.clip(region),\n        filename,\n        {\"scale\": 10, \"region\": region, \"maxPixels\": 1e13, \"driveFolder\": drive_folder},\n    )\n\n    try:\n        task.start()\n    except ee.ee_exception.EEException as e:\n        print(f\"Task not started! Got exception {e}\")\n        return task\n\n    if monitor:\n        monitor_task(task)\n\n    return task\n\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\n\ndef monitor_task(task: ee.batch.Export) -> None:\n\n    while task.status()[\"state\"] in [\"READY\", \"RUNNING\"]:\n        print(task.status())\n        # print(f\"Running: {task.status()['state']}\")\n\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n#################################\n#   END of cloudfree/utils.py   #\n#################################\n  \n  \n  \n  \n####################\n#   cloudfree.py   #\n####################\ndef calcCloudStats(img):\n    imgPoly = ee.Algorithms.GeometryConstructors.Polygon(\n        ee.Geometry(img.get(\"system:footprint\")).coordinates()\n    )\n\n    roi = ee.Geometry(img.get(\"ROI\"))\n\n    intersection = roi.intersection(imgPoly, ee.ErrorMargin(0.5))\n    cloudMask = img.select([\"cloudScore\"]).gt(cloudThresh).clip(roi).rename(\"cloudMask\")\n\n    cloudAreaImg = cloudMask.multiply(ee.Image.pixelArea())\n\n    stats = cloudAreaImg.reduceRegion(\n        **{\"reducer\": ee.Reducer.sum(), \"geometry\": roi, \"scale\": 10, \"maxPixels\": 1e12}\n    )\n\n    cloudPercent = ee.Number(stats.get(\"cloudMask\")).divide(imgPoly.area()).multiply(100)\n    coveragePercent = ee.Number(intersection.area()).divide(roi.area()).multiply(100)\n    cloudPercentROI = ee.Number(stats.get(\"cloudMask\")).divide(roi.area()).multiply(100)\n\n    img = img.set(\"CLOUDY_PERCENTAGE\", cloudPercent)\n    img = img.set(\"ROI_COVERAGE_PERCENT\", coveragePercent)\n    img = img.set(\"CLOUDY_PERCENTAGE_ROI\", cloudPercentROI)\n\n    return img\n\n\ndef computeQualityScore(img):\n    score = img.select([\"cloudScore\"]).max(img.select([\"shadowScore\"]))\n\n    score = score.reproject(\"EPSG:4326\", None, 20).reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    score = score.multiply(-1)\n\n    return img.addBands(score.rename(\"cloudShadowScore\"))\n\n\ndef computeS2CloudScore(img):\n    toa = img.select(\n        [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B9\", \"B10\", \"B11\", \"B12\",]\n    ).divide(10000)\n\n    toa = toa.addBands(img.select([\"QA60\"]))\n\n    # ['QA60', 'B1','B2',    'B3',    'B4',   'B5','B6','B7', 'B8','  B8A',\n    #  'B9',          'B10', 'B11','B12']\n    # ['QA60','cb', 'blue', 'green', 'red', 're1','re2','re3','nir', 'nir2',\n    #  'waterVapor', 'cirrus','swir1', 'swir2']);\n\n    # Compute several indicators of cloudyness and take the minimum of them.\n    score = ee.Image(1)\n\n    # Clouds are reasonably bright in the blue and cirrus bands.\n    score = score.min(rescale(toa, \"img.B2\", [0.1, 0.5]))\n    score = score.min(rescale(toa, \"img.B1\", [0.1, 0.3]))\n    score = score.min(rescale(toa, \"img.B1 + img.B10\", [0.15, 0.2]))\n\n    # Clouds are reasonably bright in all visible bands.\n    score = score.min(rescale(toa, \"img.B4 + img.B3 + img.B2\", [0.2, 0.8]))\n\n    # Clouds are moist\n    ndmi = img.normalizedDifference([\"B8\", \"B11\"])\n    score = score.min(rescale(ndmi, \"img\", [-0.1, 0.1]))\n\n    # However, clouds are not snow.\n    ndsi = img.normalizedDifference([\"B3\", \"B11\"])\n    score = score.min(rescale(ndsi, \"img\", [0.8, 0.6]))\n\n    # Clip the lower end of the score\n    score = score.max(ee.Image(0.001))\n\n    # score = score.multiply(dilated)\n    score = score.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    return img.addBands(score.rename(\"cloudScore\"))\n\n\ndef projectShadows(image):\n    meanAzimuth = image.get(\"MEAN_SOLAR_AZIMUTH_ANGLE\")\n    meanZenith = image.get(\"MEAN_SOLAR_ZENITH_ANGLE\")\n\n    cloudMask = image.select([\"cloudScore\"]).gt(cloudThresh)\n\n    # Find dark pixels\n    darkPixelsImg = image.select([\"B8\", \"B11\", \"B12\"]).divide(10000).reduce(ee.Reducer.sum())\n\n    ndvi = image.normalizedDifference([\"B8\", \"B4\"])\n    waterMask = ndvi.lt(ndviThresh)\n\n    darkPixels = darkPixelsImg.lt(irSumThresh)\n\n    # Get the mask of pixels which might be shadows excluding water\n    darkPixelMask = darkPixels.And(waterMask.Not())\n    darkPixelMask = darkPixelMask.And(cloudMask.Not())\n\n    # Find where cloud shadows should be based on solar geometry\n    # Convert to radians\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\n    zenR = ee.Number(meanZenith).multiply(math.pi).divide(180.0)\n\n    # Find the shadows\n    def getShadows(cloudHeight):\n        cloudHeight = ee.Number(cloudHeight)\n\n        shadowCastedDistance = zenR.tan().multiply(cloudHeight)  # Distance shadow is cast\n        x = azR.sin().multiply(shadowCastedDistance).multiply(-1)  # /X distance of shadow\n        y = azR.cos().multiply(shadowCastedDistance).multiply(-1)  # Y distance of shadow\n        return image.select([\"cloudScore\"]).displace(\n            ee.Image.constant(x).addBands(ee.Image.constant(y))\n        )\n\n    shadows = ee.List(cloudHeights).map(getShadows)\n    shadowMasks = ee.ImageCollection.fromImages(shadows)\n    shadowMask = shadowMasks.mean()\n\n    # Create shadow mask\n    shadowMask = dilatedErossion(shadowMask.multiply(darkPixelMask))\n\n    shadowScore = shadowMask.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.max(), \"kernel\": ee.Kernel.square(1)}\n    )\n\n    image = image.addBands(shadowScore.rename([\"shadowScore\"]))\n\n    return image\n\n\ndef dilatedErossion(score):\n    # Perform opening on the cloud scores\n    score = (\n        score.reproject(\"EPSG:4326\", None, 20)\n        .focal_min(**{\"radius\": erodePixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .focal_max(**{\"radius\": dilationPixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .reproject(\"EPSG:4326\", None, 20)\n    )\n\n    return score\n\n\ndef mergeCollection(imgC):\n    # Select the best images, which are below the cloud free threshold, sort them in reverse order\n    # (worst on top) for mosaicing\n    best = imgC.filterMetadata(\"CLOUDY_PERCENTAGE\", \"less_than\", cloudFreeKeepThresh).sort(\n        \"CLOUDY_PERCENTAGE\", False\n    )\n    filtered = imgC.qualityMosaic(\"cloudShadowScore\")\n\n    # Add the quality mosaic to fill in any missing areas of the ROI which aren't covered by good\n    # images\n    newC = ee.ImageCollection.fromImages([filtered, best.mosaic()])\n\n    return ee.Image(newC.mosaic())\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\n###########################\n#   END of cloudfree.py   #\n###########################\n  \n  \n  \n\n#########################\n#   exporters/base.py   #\n#########################\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n################################\n#   END of exporters/base.py   #\n################################\n\n\n\n\n##################################\n#   exporters/sentinel/base.py   #\n##################################\nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(combine_bands))\n\n        # and finally, export the image\n        export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n#########################################\n#   END of exporters/sentinel/base.py   #\n#########################################\n\n\n\n\n\n############################\n#   exporters/geowiki.py   #\n############################\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n###################################\n#   END of exporters/geowiki.py   #\n###################################\n\n\n\n\n#####################################\n#   exporters/sentinel/geowiki.py   #\n#####################################\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n############################################\n#   END of exporters/sentinel/geowiki.py   #\n############################################\n\n\n\n\n##############################\n#   src/processors/base.py   #\n##############################\nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n#####################################\n#   END of src/processors/base.py   #\n#####################################\n        \n  \n  \n  \n#################################\n#   src/processors/geowiki.py   #\n#################################\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n########################################\n#   END of src/processors/geowiki.py   #\n########################################\n\n\n\n##########################\n#   scripts/process.py   #\n##########################\ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n#################################\n#   END of scripts/process.py   #\n#################################\n\n\n\n#########################\n#   scripts/export.py   #\n#########################\ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n################################\n#   END of scripts/export.py   #\n################################\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1701.62it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 1 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 2 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 3 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 4 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 5 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 6 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 7 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 8 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 9 from aggregated images between 2017-03-28 and 2017-03-29\n",
  "history_begin_time" : 1644876822499,
  "history_end_time" : 1644876839390,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "aCS0o03qWGRU",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport math\nimport ee\n\n####################\n#   constants.py   #\n####################\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n###########################\n#   END of constants.py   #\n###########################\n\n\n\n####################\n#   src/utils.py   #\n####################\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n      \ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n###########################\n#   END of src/utils.py   #\n###########################\n\n\n\n\n\n################\n#   utils.py   #\n################\n@dataclass\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n#######################\n#   END of utils.py   #\n#######################\n  \n  \n  \n\n\n##########################\n#   cloudfree/utils.py   #\n##########################\ndef combine_bands(current, previous):\n    # Transforms an Image Collection with 1 band per Image into a single Image with items as bands\n    # Author: Jamie Vleeshouwer\n\n    # Rename the band\n    previous = ee.Image(previous)\n    current = current.select(BANDS)\n    # Append it to the result (Note: only return current item on first element/iteration)\n    return ee.Algorithms.If(\n        ee.Algorithms.IsEqual(previous, None), current, previous.addBands(ee.Image(current)),\n    )\n\n\ndef export(\n    image: ee.Image, region: ee.Geometry, filename: str, drive_folder: str, monitor: bool = False,\n) -> ee.batch.Export:\n\n    task = ee.batch.Export.image(\n        image.clip(region),\n        filename,\n        {\"scale\": 10, \"region\": region, \"maxPixels\": 1e13, \"driveFolder\": drive_folder},\n    )\n\n    try:\n        task.start()\n    except ee.ee_exception.EEException as e:\n        print(f\"Task not started! Got exception {e}\")\n        return task\n\n    if monitor:\n        monitor_task(task)\n\n    return task\n\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\n\ndef monitor_task(task: ee.batch.Export) -> None:\n\n    while task.status()[\"state\"] in [\"READY\", \"RUNNING\"]:\n        print(task.status())\n        # print(f\"Running: {task.status()['state']}\")\n\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n#################################\n#   END of cloudfree/utils.py   #\n#################################\n  \n  \n  \n  \n####################\n#   cloudfree.py   #\n####################\ndef calcCloudStats(img):\n    imgPoly = ee.Algorithms.GeometryConstructors.Polygon(\n        ee.Geometry(img.get(\"system:footprint\")).coordinates()\n    )\n\n    roi = ee.Geometry(img.get(\"ROI\"))\n\n    intersection = roi.intersection(imgPoly, ee.ErrorMargin(0.5))\n    cloudMask = img.select([\"cloudScore\"]).gt(cloudThresh).clip(roi).rename(\"cloudMask\")\n\n    cloudAreaImg = cloudMask.multiply(ee.Image.pixelArea())\n\n    stats = cloudAreaImg.reduceRegion(\n        **{\"reducer\": ee.Reducer.sum(), \"geometry\": roi, \"scale\": 10, \"maxPixels\": 1e12}\n    )\n\n    cloudPercent = ee.Number(stats.get(\"cloudMask\")).divide(imgPoly.area()).multiply(100)\n    coveragePercent = ee.Number(intersection.area()).divide(roi.area()).multiply(100)\n    cloudPercentROI = ee.Number(stats.get(\"cloudMask\")).divide(roi.area()).multiply(100)\n\n    img = img.set(\"CLOUDY_PERCENTAGE\", cloudPercent)\n    img = img.set(\"ROI_COVERAGE_PERCENT\", coveragePercent)\n    img = img.set(\"CLOUDY_PERCENTAGE_ROI\", cloudPercentROI)\n\n    return img\n\n\ndef computeQualityScore(img):\n    score = img.select([\"cloudScore\"]).max(img.select([\"shadowScore\"]))\n\n    score = score.reproject(\"EPSG:4326\", None, 20).reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    score = score.multiply(-1)\n\n    return img.addBands(score.rename(\"cloudShadowScore\"))\n\n\ndef computeS2CloudScore(img):\n    toa = img.select(\n        [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B9\", \"B10\", \"B11\", \"B12\",]\n    ).divide(10000)\n\n    toa = toa.addBands(img.select([\"QA60\"]))\n\n    # ['QA60', 'B1','B2',    'B3',    'B4',   'B5','B6','B7', 'B8','  B8A',\n    #  'B9',          'B10', 'B11','B12']\n    # ['QA60','cb', 'blue', 'green', 'red', 're1','re2','re3','nir', 'nir2',\n    #  'waterVapor', 'cirrus','swir1', 'swir2']);\n\n    # Compute several indicators of cloudyness and take the minimum of them.\n    score = ee.Image(1)\n\n    # Clouds are reasonably bright in the blue and cirrus bands.\n    score = score.min(rescale(toa, \"img.B2\", [0.1, 0.5]))\n    score = score.min(rescale(toa, \"img.B1\", [0.1, 0.3]))\n    score = score.min(rescale(toa, \"img.B1 + img.B10\", [0.15, 0.2]))\n\n    # Clouds are reasonably bright in all visible bands.\n    score = score.min(rescale(toa, \"img.B4 + img.B3 + img.B2\", [0.2, 0.8]))\n\n    # Clouds are moist\n    ndmi = img.normalizedDifference([\"B8\", \"B11\"])\n    score = score.min(rescale(ndmi, \"img\", [-0.1, 0.1]))\n\n    # However, clouds are not snow.\n    ndsi = img.normalizedDifference([\"B3\", \"B11\"])\n    score = score.min(rescale(ndsi, \"img\", [0.8, 0.6]))\n\n    # Clip the lower end of the score\n    score = score.max(ee.Image(0.001))\n\n    # score = score.multiply(dilated)\n    score = score.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    return img.addBands(score.rename(\"cloudScore\"))\n\n\ndef projectShadows(image):\n    meanAzimuth = image.get(\"MEAN_SOLAR_AZIMUTH_ANGLE\")\n    meanZenith = image.get(\"MEAN_SOLAR_ZENITH_ANGLE\")\n\n    cloudMask = image.select([\"cloudScore\"]).gt(cloudThresh)\n\n    # Find dark pixels\n    darkPixelsImg = image.select([\"B8\", \"B11\", \"B12\"]).divide(10000).reduce(ee.Reducer.sum())\n\n    ndvi = image.normalizedDifference([\"B8\", \"B4\"])\n    waterMask = ndvi.lt(ndviThresh)\n\n    darkPixels = darkPixelsImg.lt(irSumThresh)\n\n    # Get the mask of pixels which might be shadows excluding water\n    darkPixelMask = darkPixels.And(waterMask.Not())\n    darkPixelMask = darkPixelMask.And(cloudMask.Not())\n\n    # Find where cloud shadows should be based on solar geometry\n    # Convert to radians\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\n    zenR = ee.Number(meanZenith).multiply(math.pi).divide(180.0)\n\n    # Find the shadows\n    def getShadows(cloudHeight):\n        cloudHeight = ee.Number(cloudHeight)\n\n        shadowCastedDistance = zenR.tan().multiply(cloudHeight)  # Distance shadow is cast\n        x = azR.sin().multiply(shadowCastedDistance).multiply(-1)  # /X distance of shadow\n        y = azR.cos().multiply(shadowCastedDistance).multiply(-1)  # Y distance of shadow\n        return image.select([\"cloudScore\"]).displace(\n            ee.Image.constant(x).addBands(ee.Image.constant(y))\n        )\n\n    shadows = ee.List(cloudHeights).map(getShadows)\n    shadowMasks = ee.ImageCollection.fromImages(shadows)\n    shadowMask = shadowMasks.mean()\n\n    # Create shadow mask\n    shadowMask = dilatedErossion(shadowMask.multiply(darkPixelMask))\n\n    shadowScore = shadowMask.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.max(), \"kernel\": ee.Kernel.square(1)}\n    )\n\n    image = image.addBands(shadowScore.rename([\"shadowScore\"]))\n\n    return image\n\n\ndef dilatedErossion(score):\n    # Perform opening on the cloud scores\n    score = (\n        score.reproject(\"EPSG:4326\", None, 20)\n        .focal_min(**{\"radius\": erodePixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .focal_max(**{\"radius\": dilationPixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .reproject(\"EPSG:4326\", None, 20)\n    )\n\n    return score\n\n\ndef mergeCollection(imgC):\n    # Select the best images, which are below the cloud free threshold, sort them in reverse order\n    # (worst on top) for mosaicing\n    best = imgC.filterMetadata(\"CLOUDY_PERCENTAGE\", \"less_than\", cloudFreeKeepThresh).sort(\n        \"CLOUDY_PERCENTAGE\", False\n    )\n    filtered = imgC.qualityMosaic(\"cloudShadowScore\")\n\n    # Add the quality mosaic to fill in any missing areas of the ROI which aren't covered by good\n    # images\n    newC = ee.ImageCollection.fromImages([filtered, best.mosaic()])\n\n    return ee.Image(newC.mosaic())\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\n###########################\n#   END of cloudfree.py   #\n###########################\n  \n  \n  \n\n#########################\n#   exporters/base.py   #\n#########################\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n################################\n#   END of exporters/base.py   #\n################################\n\n\n\n\n##################################\n#   exporters/sentinel/base.py   #\n##################################\nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(combine_bands))\n\n        # and finally, export the image\n        export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n#########################################\n#   END of exporters/sentinel/base.py   #\n#########################################\n\n\n\n\n\n############################\n#   exporters/geowiki.py   #\n############################\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n###################################\n#   END of exporters/geowiki.py   #\n###################################\n\n\n\n\n#####################################\n#   exporters/sentinel/geowiki.py   #\n#####################################\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n############################################\n#   END of exporters/sentinel/geowiki.py   #\n############################################\n\n\n\n\n##############################\n#   src/processors/base.py   #\n##############################\nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n#####################################\n#   END of src/processors/base.py   #\n#####################################\n        \n  \n  \n  \n#################################\n#   src/processors/geowiki.py   #\n#################################\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n########################################\n#   END of src/processors/geowiki.py   #\n########################################\n\n\n\n##########################\n#   scripts/process.py   #\n##########################\ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n#################################\n#   END of scripts/process.py   #\n#################################\n\n\n\n#########################\n#   scripts/export.py   #\n#########################\ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n################################\n#   END of scripts/export.py   #\n################################\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1474.96it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 1 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 2 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 3 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 4 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 5 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 6 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 7 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 8 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 9 from aggregated images between 2017-03-28 and 2017-03-29\n",
  "history_begin_time" : 1644875257812,
  "history_end_time" : 1644875272247,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "xv6oDn0gvXjk",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport math\nimport ee\n\n####################\n#   constants.py   #\n####################\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n###########################\n#   END of constants.py   #\n###########################\n\n\n\n####################\n#   constants.py   #\n####################\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n  \n\n\n##########################\n#   cloudfree/utils.py   #\n##########################\n\ndef combine_bands(current, previous):\n    # Transforms an Image Collection with 1 band per Image into a single Image with items as bands\n    # Author: Jamie Vleeshouwer\n\n    # Rename the band\n    previous = ee.Image(previous)\n    current = current.select(BANDS)\n    # Append it to the result (Note: only return current item on first element/iteration)\n    return ee.Algorithms.If(\n        ee.Algorithms.IsEqual(previous, None), current, previous.addBands(ee.Image(current)),\n    )\n\n\ndef export(\n    image: ee.Image, region: ee.Geometry, filename: str, drive_folder: str, monitor: bool = False,\n) -> ee.batch.Export:\n\n    task = ee.batch.Export.image(\n        image.clip(region),\n        filename,\n        {\"scale\": 10, \"region\": region, \"maxPixels\": 1e13, \"driveFolder\": drive_folder},\n    )\n\n    try:\n        task.start()\n    except ee.ee_exception.EEException as e:\n        print(f\"Task not started! Got exception {e}\")\n        return task\n\n    if monitor:\n        monitor_task(task)\n\n    return task\n\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\n\ndef monitor_task(task: ee.batch.Export) -> None:\n\n    while task.status()[\"state\"] in [\"READY\", \"RUNNING\"]:\n        print(task.status())\n        # print(f\"Running: {task.status()['state']}\")\n\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n#################################\n#   END of cloudfree/utils.py   #\n#################################\n  \n  \n####################\n#   cloudfree.py   #\n####################\n\ndef calcCloudStats(img):\n    imgPoly = ee.Algorithms.GeometryConstructors.Polygon(\n        ee.Geometry(img.get(\"system:footprint\")).coordinates()\n    )\n\n    roi = ee.Geometry(img.get(\"ROI\"))\n\n    intersection = roi.intersection(imgPoly, ee.ErrorMargin(0.5))\n    cloudMask = img.select([\"cloudScore\"]).gt(cloudThresh).clip(roi).rename(\"cloudMask\")\n\n    cloudAreaImg = cloudMask.multiply(ee.Image.pixelArea())\n\n    stats = cloudAreaImg.reduceRegion(\n        **{\"reducer\": ee.Reducer.sum(), \"geometry\": roi, \"scale\": 10, \"maxPixels\": 1e12}\n    )\n\n    cloudPercent = ee.Number(stats.get(\"cloudMask\")).divide(imgPoly.area()).multiply(100)\n    coveragePercent = ee.Number(intersection.area()).divide(roi.area()).multiply(100)\n    cloudPercentROI = ee.Number(stats.get(\"cloudMask\")).divide(roi.area()).multiply(100)\n\n    img = img.set(\"CLOUDY_PERCENTAGE\", cloudPercent)\n    img = img.set(\"ROI_COVERAGE_PERCENT\", coveragePercent)\n    img = img.set(\"CLOUDY_PERCENTAGE_ROI\", cloudPercentROI)\n\n    return img\n\n\ndef computeQualityScore(img):\n    score = img.select([\"cloudScore\"]).max(img.select([\"shadowScore\"]))\n\n    score = score.reproject(\"EPSG:4326\", None, 20).reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    score = score.multiply(-1)\n\n    return img.addBands(score.rename(\"cloudShadowScore\"))\n\n\ndef computeS2CloudScore(img):\n    toa = img.select(\n        [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B9\", \"B10\", \"B11\", \"B12\",]\n    ).divide(10000)\n\n    toa = toa.addBands(img.select([\"QA60\"]))\n\n    # ['QA60', 'B1','B2',    'B3',    'B4',   'B5','B6','B7', 'B8','  B8A',\n    #  'B9',          'B10', 'B11','B12']\n    # ['QA60','cb', 'blue', 'green', 'red', 're1','re2','re3','nir', 'nir2',\n    #  'waterVapor', 'cirrus','swir1', 'swir2']);\n\n    # Compute several indicators of cloudyness and take the minimum of them.\n    score = ee.Image(1)\n\n    # Clouds are reasonably bright in the blue and cirrus bands.\n    score = score.min(rescale(toa, \"img.B2\", [0.1, 0.5]))\n    score = score.min(rescale(toa, \"img.B1\", [0.1, 0.3]))\n    score = score.min(rescale(toa, \"img.B1 + img.B10\", [0.15, 0.2]))\n\n    # Clouds are reasonably bright in all visible bands.\n    score = score.min(rescale(toa, \"img.B4 + img.B3 + img.B2\", [0.2, 0.8]))\n\n    # Clouds are moist\n    ndmi = img.normalizedDifference([\"B8\", \"B11\"])\n    score = score.min(rescale(ndmi, \"img\", [-0.1, 0.1]))\n\n    # However, clouds are not snow.\n    ndsi = img.normalizedDifference([\"B3\", \"B11\"])\n    score = score.min(rescale(ndsi, \"img\", [0.8, 0.6]))\n\n    # Clip the lower end of the score\n    score = score.max(ee.Image(0.001))\n\n    # score = score.multiply(dilated)\n    score = score.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    return img.addBands(score.rename(\"cloudScore\"))\n\n\ndef projectShadows(image):\n    meanAzimuth = image.get(\"MEAN_SOLAR_AZIMUTH_ANGLE\")\n    meanZenith = image.get(\"MEAN_SOLAR_ZENITH_ANGLE\")\n\n    cloudMask = image.select([\"cloudScore\"]).gt(cloudThresh)\n\n    # Find dark pixels\n    darkPixelsImg = image.select([\"B8\", \"B11\", \"B12\"]).divide(10000).reduce(ee.Reducer.sum())\n\n    ndvi = image.normalizedDifference([\"B8\", \"B4\"])\n    waterMask = ndvi.lt(ndviThresh)\n\n    darkPixels = darkPixelsImg.lt(irSumThresh)\n\n    # Get the mask of pixels which might be shadows excluding water\n    darkPixelMask = darkPixels.And(waterMask.Not())\n    darkPixelMask = darkPixelMask.And(cloudMask.Not())\n\n    # Find where cloud shadows should be based on solar geometry\n    # Convert to radians\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\n    zenR = ee.Number(meanZenith).multiply(math.pi).divide(180.0)\n\n    # Find the shadows\n    def getShadows(cloudHeight):\n        cloudHeight = ee.Number(cloudHeight)\n\n        shadowCastedDistance = zenR.tan().multiply(cloudHeight)  # Distance shadow is cast\n        x = azR.sin().multiply(shadowCastedDistance).multiply(-1)  # /X distance of shadow\n        y = azR.cos().multiply(shadowCastedDistance).multiply(-1)  # Y distance of shadow\n        return image.select([\"cloudScore\"]).displace(\n            ee.Image.constant(x).addBands(ee.Image.constant(y))\n        )\n\n    shadows = ee.List(cloudHeights).map(getShadows)\n    shadowMasks = ee.ImageCollection.fromImages(shadows)\n    shadowMask = shadowMasks.mean()\n\n    # Create shadow mask\n    shadowMask = dilatedErossion(shadowMask.multiply(darkPixelMask))\n\n    shadowScore = shadowMask.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.max(), \"kernel\": ee.Kernel.square(1)}\n    )\n\n    image = image.addBands(shadowScore.rename([\"shadowScore\"]))\n\n    return image\n\n\ndef dilatedErossion(score):\n    # Perform opening on the cloud scores\n    score = (\n        score.reproject(\"EPSG:4326\", None, 20)\n        .focal_min(**{\"radius\": erodePixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .focal_max(**{\"radius\": dilationPixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .reproject(\"EPSG:4326\", None, 20)\n    )\n\n    return score\n\n\ndef mergeCollection(imgC):\n    # Select the best images, which are below the cloud free threshold, sort them in reverse order\n    # (worst on top) for mosaicing\n    best = imgC.filterMetadata(\"CLOUDY_PERCENTAGE\", \"less_than\", cloudFreeKeepThresh).sort(\n        \"CLOUDY_PERCENTAGE\", False\n    )\n    filtered = imgC.qualityMosaic(\"cloudShadowScore\")\n\n    # Add the quality mosaic to fill in any missing areas of the ROI which aren't covered by good\n    # images\n    newC = ee.ImageCollection.fromImages([filtered, best.mosaic()])\n\n    return ee.Image(newC.mosaic())\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\n###########################\n#   END of cloudfree.py   #\n###########################\n  \n  \nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(combine_bands))\n\n        # and finally, export the image\n        export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1397.74it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 1 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 2 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 3 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 4 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 5 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 6 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 7 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 8 from aggregated images between 2017-03-28 and 2017-03-29\nExporting image for polygon 9 from aggregated images between 2017-03-28 and 2017-03-29\n",
  "history_begin_time" : 1644873592553,
  "history_end_time" : 1644873606273,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "tyFrBqSsPggf",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport math\nimport ee\n\n####################\n#   constants.py   #\n####################\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n###########################\n#   END of constants.py   #\n###########################\n\n\n\n####################\n#   constants.py   #\n####################\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n  \n####################\n#   cloudfree.py   #\n####################\n\ndef calcCloudStats(img):\n    imgPoly = ee.Algorithms.GeometryConstructors.Polygon(\n        ee.Geometry(img.get(\"system:footprint\")).coordinates()\n    )\n\n    roi = ee.Geometry(img.get(\"ROI\"))\n\n    intersection = roi.intersection(imgPoly, ee.ErrorMargin(0.5))\n    cloudMask = img.select([\"cloudScore\"]).gt(cloudThresh).clip(roi).rename(\"cloudMask\")\n\n    cloudAreaImg = cloudMask.multiply(ee.Image.pixelArea())\n\n    stats = cloudAreaImg.reduceRegion(\n        **{\"reducer\": ee.Reducer.sum(), \"geometry\": roi, \"scale\": 10, \"maxPixels\": 1e12}\n    )\n\n    cloudPercent = ee.Number(stats.get(\"cloudMask\")).divide(imgPoly.area()).multiply(100)\n    coveragePercent = ee.Number(intersection.area()).divide(roi.area()).multiply(100)\n    cloudPercentROI = ee.Number(stats.get(\"cloudMask\")).divide(roi.area()).multiply(100)\n\n    img = img.set(\"CLOUDY_PERCENTAGE\", cloudPercent)\n    img = img.set(\"ROI_COVERAGE_PERCENT\", coveragePercent)\n    img = img.set(\"CLOUDY_PERCENTAGE_ROI\", cloudPercentROI)\n\n    return img\n\n\ndef computeQualityScore(img):\n    score = img.select([\"cloudScore\"]).max(img.select([\"shadowScore\"]))\n\n    score = score.reproject(\"EPSG:4326\", None, 20).reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    score = score.multiply(-1)\n\n    return img.addBands(score.rename(\"cloudShadowScore\"))\n\n\ndef computeS2CloudScore(img):\n    toa = img.select(\n        [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B9\", \"B10\", \"B11\", \"B12\",]\n    ).divide(10000)\n\n    toa = toa.addBands(img.select([\"QA60\"]))\n\n    # ['QA60', 'B1','B2',    'B3',    'B4',   'B5','B6','B7', 'B8','  B8A',\n    #  'B9',          'B10', 'B11','B12']\n    # ['QA60','cb', 'blue', 'green', 'red', 're1','re2','re3','nir', 'nir2',\n    #  'waterVapor', 'cirrus','swir1', 'swir2']);\n\n    # Compute several indicators of cloudyness and take the minimum of them.\n    score = ee.Image(1)\n\n    # Clouds are reasonably bright in the blue and cirrus bands.\n    score = score.min(rescale(toa, \"img.B2\", [0.1, 0.5]))\n    score = score.min(rescale(toa, \"img.B1\", [0.1, 0.3]))\n    score = score.min(rescale(toa, \"img.B1 + img.B10\", [0.15, 0.2]))\n\n    # Clouds are reasonably bright in all visible bands.\n    score = score.min(rescale(toa, \"img.B4 + img.B3 + img.B2\", [0.2, 0.8]))\n\n    # Clouds are moist\n    ndmi = img.normalizedDifference([\"B8\", \"B11\"])\n    score = score.min(rescale(ndmi, \"img\", [-0.1, 0.1]))\n\n    # However, clouds are not snow.\n    ndsi = img.normalizedDifference([\"B3\", \"B11\"])\n    score = score.min(rescale(ndsi, \"img\", [0.8, 0.6]))\n\n    # Clip the lower end of the score\n    score = score.max(ee.Image(0.001))\n\n    # score = score.multiply(dilated)\n    score = score.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    return img.addBands(score.rename(\"cloudScore\"))\n\n\ndef projectShadows(image):\n    meanAzimuth = image.get(\"MEAN_SOLAR_AZIMUTH_ANGLE\")\n    meanZenith = image.get(\"MEAN_SOLAR_ZENITH_ANGLE\")\n\n    cloudMask = image.select([\"cloudScore\"]).gt(cloudThresh)\n\n    # Find dark pixels\n    darkPixelsImg = image.select([\"B8\", \"B11\", \"B12\"]).divide(10000).reduce(ee.Reducer.sum())\n\n    ndvi = image.normalizedDifference([\"B8\", \"B4\"])\n    waterMask = ndvi.lt(ndviThresh)\n\n    darkPixels = darkPixelsImg.lt(irSumThresh)\n\n    # Get the mask of pixels which might be shadows excluding water\n    darkPixelMask = darkPixels.And(waterMask.Not())\n    darkPixelMask = darkPixelMask.And(cloudMask.Not())\n\n    # Find where cloud shadows should be based on solar geometry\n    # Convert to radians\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\n    zenR = ee.Number(meanZenith).multiply(math.pi).divide(180.0)\n\n    # Find the shadows\n    def getShadows(cloudHeight):\n        cloudHeight = ee.Number(cloudHeight)\n\n        shadowCastedDistance = zenR.tan().multiply(cloudHeight)  # Distance shadow is cast\n        x = azR.sin().multiply(shadowCastedDistance).multiply(-1)  # /X distance of shadow\n        y = azR.cos().multiply(shadowCastedDistance).multiply(-1)  # Y distance of shadow\n        return image.select([\"cloudScore\"]).displace(\n            ee.Image.constant(x).addBands(ee.Image.constant(y))\n        )\n\n    shadows = ee.List(cloudHeights).map(getShadows)\n    shadowMasks = ee.ImageCollection.fromImages(shadows)\n    shadowMask = shadowMasks.mean()\n\n    # Create shadow mask\n    shadowMask = dilatedErossion(shadowMask.multiply(darkPixelMask))\n\n    shadowScore = shadowMask.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.max(), \"kernel\": ee.Kernel.square(1)}\n    )\n\n    image = image.addBands(shadowScore.rename([\"shadowScore\"]))\n\n    return image\n\n\ndef dilatedErossion(score):\n    # Perform opening on the cloud scores\n    score = (\n        score.reproject(\"EPSG:4326\", None, 20)\n        .focal_min(**{\"radius\": erodePixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .focal_max(**{\"radius\": dilationPixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .reproject(\"EPSG:4326\", None, 20)\n    )\n\n    return score\n\n\ndef mergeCollection(imgC):\n    # Select the best images, which are below the cloud free threshold, sort them in reverse order\n    # (worst on top) for mosaicing\n    best = imgC.filterMetadata(\"CLOUDY_PERCENTAGE\", \"less_than\", cloudFreeKeepThresh).sort(\n        \"CLOUDY_PERCENTAGE\", False\n    )\n    filtered = imgC.qualityMosaic(\"cloudShadowScore\")\n\n    # Add the quality mosaic to fill in any missing areas of the ROI which aren't covered by good\n    # images\n    newC = ee.ImageCollection.fromImages([filtered, best.mosaic()])\n\n    return ee.Image(newC.mosaic())\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\n###########################\n#   END of cloudfree.py   #\n###########################\n  \n  \nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1229.48it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 699, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 695, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 605, in export_for_labels\n    self._export_for_polygon(\n  File \"export_GeoWiki_sentinel_gee.py\", line 482, in _export_for_polygon\n    img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\nNameError: name 'cloudfree' is not defined\n",
  "history_begin_time" : 1644873423711,
  "history_end_time" : 1644873430843,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "YkgoTFI4SwUa",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport ee\n\n####################\n#   constants.py   #\n####################\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n###########################\n#   END of constants.py   #\n###########################\n\n\n\n####################\n#   constants.py   #\n####################\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n  \n####################\n#   cloudfree.py   #\n####################\n\ndef calcCloudStats(img):\n    imgPoly = ee.Algorithms.GeometryConstructors.Polygon(\n        ee.Geometry(img.get(\"system:footprint\")).coordinates()\n    )\n\n    roi = ee.Geometry(img.get(\"ROI\"))\n\n    intersection = roi.intersection(imgPoly, ee.ErrorMargin(0.5))\n    cloudMask = img.select([\"cloudScore\"]).gt(cloudThresh).clip(roi).rename(\"cloudMask\")\n\n    cloudAreaImg = cloudMask.multiply(ee.Image.pixelArea())\n\n    stats = cloudAreaImg.reduceRegion(\n        **{\"reducer\": ee.Reducer.sum(), \"geometry\": roi, \"scale\": 10, \"maxPixels\": 1e12}\n    )\n\n    cloudPercent = ee.Number(stats.get(\"cloudMask\")).divide(imgPoly.area()).multiply(100)\n    coveragePercent = ee.Number(intersection.area()).divide(roi.area()).multiply(100)\n    cloudPercentROI = ee.Number(stats.get(\"cloudMask\")).divide(roi.area()).multiply(100)\n\n    img = img.set(\"CLOUDY_PERCENTAGE\", cloudPercent)\n    img = img.set(\"ROI_COVERAGE_PERCENT\", coveragePercent)\n    img = img.set(\"CLOUDY_PERCENTAGE_ROI\", cloudPercentROI)\n\n    return img\n\n\ndef computeQualityScore(img):\n    score = img.select([\"cloudScore\"]).max(img.select([\"shadowScore\"]))\n\n    score = score.reproject(\"EPSG:4326\", None, 20).reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    score = score.multiply(-1)\n\n    return img.addBands(score.rename(\"cloudShadowScore\"))\n\n\ndef computeS2CloudScore(img):\n    toa = img.select(\n        [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B8A\", \"B9\", \"B10\", \"B11\", \"B12\",]\n    ).divide(10000)\n\n    toa = toa.addBands(img.select([\"QA60\"]))\n\n    # ['QA60', 'B1','B2',    'B3',    'B4',   'B5','B6','B7', 'B8','  B8A',\n    #  'B9',          'B10', 'B11','B12']\n    # ['QA60','cb', 'blue', 'green', 'red', 're1','re2','re3','nir', 'nir2',\n    #  'waterVapor', 'cirrus','swir1', 'swir2']);\n\n    # Compute several indicators of cloudyness and take the minimum of them.\n    score = ee.Image(1)\n\n    # Clouds are reasonably bright in the blue and cirrus bands.\n    score = score.min(rescale(toa, \"img.B2\", [0.1, 0.5]))\n    score = score.min(rescale(toa, \"img.B1\", [0.1, 0.3]))\n    score = score.min(rescale(toa, \"img.B1 + img.B10\", [0.15, 0.2]))\n\n    # Clouds are reasonably bright in all visible bands.\n    score = score.min(rescale(toa, \"img.B4 + img.B3 + img.B2\", [0.2, 0.8]))\n\n    # Clouds are moist\n    ndmi = img.normalizedDifference([\"B8\", \"B11\"])\n    score = score.min(rescale(ndmi, \"img\", [-0.1, 0.1]))\n\n    # However, clouds are not snow.\n    ndsi = img.normalizedDifference([\"B3\", \"B11\"])\n    score = score.min(rescale(ndsi, \"img\", [0.8, 0.6]))\n\n    # Clip the lower end of the score\n    score = score.max(ee.Image(0.001))\n\n    # score = score.multiply(dilated)\n    score = score.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.mean(), \"kernel\": ee.Kernel.square(5)}\n    )\n\n    return img.addBands(score.rename(\"cloudScore\"))\n\n\ndef projectShadows(image):\n    meanAzimuth = image.get(\"MEAN_SOLAR_AZIMUTH_ANGLE\")\n    meanZenith = image.get(\"MEAN_SOLAR_ZENITH_ANGLE\")\n\n    cloudMask = image.select([\"cloudScore\"]).gt(cloudThresh)\n\n    # Find dark pixels\n    darkPixelsImg = image.select([\"B8\", \"B11\", \"B12\"]).divide(10000).reduce(ee.Reducer.sum())\n\n    ndvi = image.normalizedDifference([\"B8\", \"B4\"])\n    waterMask = ndvi.lt(ndviThresh)\n\n    darkPixels = darkPixelsImg.lt(irSumThresh)\n\n    # Get the mask of pixels which might be shadows excluding water\n    darkPixelMask = darkPixels.And(waterMask.Not())\n    darkPixelMask = darkPixelMask.And(cloudMask.Not())\n\n    # Find where cloud shadows should be based on solar geometry\n    # Convert to radians\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\n    zenR = ee.Number(meanZenith).multiply(math.pi).divide(180.0)\n\n    # Find the shadows\n    def getShadows(cloudHeight):\n        cloudHeight = ee.Number(cloudHeight)\n\n        shadowCastedDistance = zenR.tan().multiply(cloudHeight)  # Distance shadow is cast\n        x = azR.sin().multiply(shadowCastedDistance).multiply(-1)  # /X distance of shadow\n        y = azR.cos().multiply(shadowCastedDistance).multiply(-1)  # Y distance of shadow\n        return image.select([\"cloudScore\"]).displace(\n            ee.Image.constant(x).addBands(ee.Image.constant(y))\n        )\n\n    shadows = ee.List(cloudHeights).map(getShadows)\n    shadowMasks = ee.ImageCollection.fromImages(shadows)\n    shadowMask = shadowMasks.mean()\n\n    # Create shadow mask\n    shadowMask = dilatedErossion(shadowMask.multiply(darkPixelMask))\n\n    shadowScore = shadowMask.reduceNeighborhood(\n        **{\"reducer\": ee.Reducer.max(), \"kernel\": ee.Kernel.square(1)}\n    )\n\n    image = image.addBands(shadowScore.rename([\"shadowScore\"]))\n\n    return image\n\n\ndef dilatedErossion(score):\n    # Perform opening on the cloud scores\n    score = (\n        score.reproject(\"EPSG:4326\", None, 20)\n        .focal_min(**{\"radius\": erodePixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .focal_max(**{\"radius\": dilationPixels, \"kernelType\": \"circle\", \"iterations\": 3})\n        .reproject(\"EPSG:4326\", None, 20)\n    )\n\n    return score\n\n\ndef mergeCollection(imgC):\n    # Select the best images, which are below the cloud free threshold, sort them in reverse order\n    # (worst on top) for mosaicing\n    best = imgC.filterMetadata(\"CLOUDY_PERCENTAGE\", \"less_than\", cloudFreeKeepThresh).sort(\n        \"CLOUDY_PERCENTAGE\", False\n    )\n    filtered = imgC.qualityMosaic(\"cloudShadowScore\")\n\n    # Add the quality mosaic to fill in any missing areas of the ROI which aren't covered by good\n    # images\n    newC = ee.ImageCollection.fromImages([filtered, best.mosaic()])\n\n    return ee.Image(newC.mosaic())\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\n###########################\n#   END of cloudfree.py   #\n###########################\n  \n  \nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1447.42it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 698, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 694, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 604, in export_for_labels\n    self._export_for_polygon(\n  File \"export_GeoWiki_sentinel_gee.py\", line 474, in _export_for_polygon\n    export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n  File \"export_GeoWiki_sentinel_gee.py\", line 355, in get_single_image_fast\n    imgC.map(lambda x: x.clip(region))\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/collection.py\", line 198, in map\n    return self._cast(apifunction.ApiFunction.call_(\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/apifunction.py\", line 81, in call_\n    return cls.lookup(name).call(*args, **kwargs)\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/function.py\", line 67, in call\n    return self.apply(self.nameArgs(args, kwargs))\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/function.py\", line 80, in apply\n    result = computedobject.ComputedObject(self, self.promoteArgs(named_args))\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/function.py\", line 107, in promoteArgs\n    promoted_args[name] = Function._promoter(args[name], spec['type'])\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/__init__.py\", line 245, in _Promote\n    return CustomFunction.create(arg, 'Object', ['Object'] * args_count)\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/customfunction.py\", line 121, in create\n    return CustomFunction(signature, func)\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/customfunction.py\", line 43, in __init__\n    self._signature = CustomFunction._resolveNamelessArgs(\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/customfunction.py\", line 166, in _resolveNamelessArgs\n    serialized_body = serializer.encode(body(*variables), for_cloud_api=True)\n  File \"/opt/anaconda3/lib/python3.8/site-packages/ee/collection.py\", line 197, in <lambda>\n    with_cast = lambda e: algorithm(element_type(e))\n  File \"export_GeoWiki_sentinel_gee.py\", line 290, in projectShadows\n    azR = ee.Number(meanAzimuth).add(180).multiply(math.pi).divide(180.0)\nNameError: name 'math' is not defined\n",
  "history_begin_time" : 1644873391878,
  "history_end_time" : 1644873399768,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "R29K6FfPjkfy",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date, timedelta\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport ee\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1473.24it/s]\nExporting image for polygon 0 from aggregated images between 2017-03-28 and 2017-03-29\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 520, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 516, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 426, in export_for_labels\n    self._export_for_polygon(\n  File \"export_GeoWiki_sentinel_gee.py\", line 296, in _export_for_polygon\n    export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n  File \"export_GeoWiki_sentinel_gee.py\", line 184, in get_single_image_fast\n    .map(computeS2CloudScore)\nNameError: name 'computeS2CloudScore' is not defined\n",
  "history_begin_time" : 1644873149482,
  "history_end_time" : 1644873157075,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "olCzCm2zqFBJ",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport ee\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n  \ndef get_single_image(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(calcCloudStats)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = get_single_image_fast\n        else:\n            export_func = get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1422.49it/s]\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 520, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 516, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 426, in export_for_labels\n    self._export_for_polygon(\n  File \"export_GeoWiki_sentinel_gee.py\", line 279, in _export_for_polygon\n    cur_end_date = cur_date + timedelta(days=days_per_timestep)\nNameError: name 'timedelta' is not defined\n",
  "history_begin_time" : 1644873088170,
  "history_end_time" : 1644873095394,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "quzxHDnJGjo9",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport ee\n\n# These are algorithm settings for the cloud filtering algorithm\nimage_collection = \"COPERNICUS/S2\"\n\n# Ranges from 0-1.Lower value will mask more pixels out.\n# Generally 0.1-0.3 works well with 0.2 being used most commonly\ncloudThresh = 0.2\n# Height of clouds to use to project cloud shadows\ncloudHeights = [200, 10000, 250]\n# Sum of IR bands to include as shadows within TDOM and the\n# shadow shift method (lower number masks out less)\nirSumThresh = 0.3\nndviThresh = -0.1\n# Pixels to reduce cloud mask and dark shadows by to reduce inclusion\n# of single-pixel comission errors\nerodePixels = 1.5\ndilationPixels = 3\n\n# images with less than this many cloud pixels will be used with normal\n# mosaicing (most recent on top)\ncloudFreeKeepThresh = 3\n\nBANDS = [\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B8A\",\n    \"B9\",\n    \"B10\",\n    \"B11\",\n    \"B12\",\n]\n\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\ndef date_to_string(input_date: Union[date, str]) -> str:\n    if isinstance(input_date, str):\n        return input_date\n    else:\n        assert isinstance(input_date, date)\n        return input_date.strftime(\"%Y-%m-%d\")\n\ndef rescale(img, exp, thresholds):\n    return (\n        img.expression(exp, {\"img\": img})\n        .subtract(thresholds[0])\n        .divide(thresholds[1] - thresholds[0])\n    )\n\ndef get_single_image_fast(region: ee.Geometry, start_date: date, end_date: date) -> ee.Image:\n\n    dates = ee.DateRange(date_to_string(start_date), date_to_string(end_date),)\n\n    startDate = ee.DateRange(dates).start()\n    endDate = ee.DateRange(dates).end()\n    imgC = ee.ImageCollection(image_collection).filterDate(startDate, endDate).filterBounds(region)\n\n    imgC = (\n        imgC.map(lambda x: x.clip(region))\n        .map(lambda x: x.set(\"ROI\", region))\n        .map(computeS2CloudScore)\n        .map(projectShadows)\n        .map(computeQualityScore)\n        .sort(\"CLOUDY_PIXEL_PERCENTAGE\")\n    )\n\n    cloudFree = mergeCollection(imgC)\n\n    return cloudFree\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1369.84it/s]\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 498, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 494, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 404, in export_for_labels\n    self._export_for_polygon(\n  File \"export_GeoWiki_sentinel_gee.py\", line 252, in _export_for_polygon\n    export_func = cloudfree.get_single_image_fast\nNameError: name 'cloudfree' is not defined\n",
  "history_begin_time" : 1644873002959,
  "history_end_time" : 1644873011354,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "L8Hc7VtTTUNR",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nfrom math import cos, radians\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n9it [00:00, 1496.54it/s]\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 426, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 422, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 332, in export_for_labels\n    self._export_for_polygon(\n  File \"export_GeoWiki_sentinel_gee.py\", line 180, in _export_for_polygon\n    export_func = cloudfree.get_single_image_fast\nNameError: name 'cloudfree' is not defined\n",
  "history_begin_time" : 1644872572073,
  "history_end_time" : 1644872578547,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "uk6sJAJTMGOE",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\ndef metre_per_degree(mid_lat: float) -> Tuple[float, float]:\n    # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n    # see the link above to explain the magic numbers\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\n    m_per_deg_lon = (3.14159265359 / 180) * 6367449 * cos(radians(mid_lat))\n\n    return m_per_deg_lat, m_per_deg_lon\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n0it [00:00, ?it/s]\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 425, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 421, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 326, in export_for_labels\n    bounding_boxes_to_download = self.labels_to_bounding_boxes(\n  File \"export_GeoWiki_sentinel_gee.py\", line 287, in labels_to_bounding_boxes\n    bounding_box_from_centre(\n  File \"export_GeoWiki_sentinel_gee.py\", line 105, in bounding_box_from_centre\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n  File \"export_GeoWiki_sentinel_gee.py\", line 96, in metre_per_degree\n    m_per_deg_lat = 111132.954 - 559.822 * cos(2.0 * mid_lat) + 1.175 * cos(radians(4.0 * mid_lat))\nNameError: name 'cos' is not defined\n",
  "history_begin_time" : 1644872525464,
  "history_end_time" : 1644872531332,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "KCkpSilk87r6",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nimport random\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "0it [00:00, ?it/s]\n0it [00:00, ?it/s]\nTraceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 418, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 414, in export_geowiki_sentinel_ee\n    exporter.export_for_labels(\n  File \"export_GeoWiki_sentinel_gee.py\", line 319, in export_for_labels\n    bounding_boxes_to_download = self.labels_to_bounding_boxes(\n  File \"export_GeoWiki_sentinel_gee.py\", line 280, in labels_to_bounding_boxes\n    bounding_box_from_centre(\n  File \"export_GeoWiki_sentinel_gee.py\", line 98, in bounding_box_from_centre\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\nNameError: name 'metre_per_degree' is not defined\n",
  "history_begin_time" : 1644872436384,
  "history_end_time" : 1644872441701,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "8wdQJ0Vkhc0F",
  "history_input" : "'''\nThis process requires Google Earth Engine creds on machine running it.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date\nimport torch\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 416, in <module>\n    process_geowiki()\n  File \"export_GeoWiki_sentinel_gee.py\", line 408, in process_geowiki\n    processor = GeoWikiProcessor(Path(\"../data\"))\n  File \"export_GeoWiki_sentinel_gee.py\", line 351, in __init__\n    set_seed()\n  File \"export_GeoWiki_sentinel_gee.py\", line 337, in set_seed\n    random.seed(seed)\nNameError: name 'random' is not defined\n",
  "history_begin_time" : 1644872414269,
  "history_end_time" : 1644872420483,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "b0vWGmBhxVr2",
  "history_input" : "'''\nThis process requires Google Earth Engine creds.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport numpy as np\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 415, in <module>\n    process_geowiki()\n  File \"export_GeoWiki_sentinel_gee.py\", line 407, in process_geowiki\n    processor = GeoWikiProcessor(Path(\"../data\"))\n  File \"export_GeoWiki_sentinel_gee.py\", line 350, in __init__\n    set_seed()\n  File \"export_GeoWiki_sentinel_gee.py\", line 335, in set_seed\n    torch.manual_seed(seed)\nNameError: name 'torch' is not defined\n",
  "history_begin_time" : 1644872302129,
  "history_end_time" : 1644872304521,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "q7eRDvQBn8y0",
  "history_input" : "'''\nThis node process requires Google Earth Engine creds.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\ndef set_seed(seed: int = 42) -> None:\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    random.seed(seed)\n    \nclass BaseProcessor:\n    r\"\"\"Base for all processor classes. It creates the appropriate\n    directory in the data dir (``data_dir/processed/{dataset}``).\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n\n    def __init__(self, data_folder: Path) -> None:\n\n        set_seed()\n        self.data_folder = data_folder\n        self.raw_folder = self.data_folder / \"raw\" / self.dataset\n        assert self.raw_folder.exists(), f\"{self.raw_folder} does not exist!\"\n\n        self.output_folder = self.data_folder / \"processed\" / self.dataset\n        self.output_folder.mkdir(exist_ok=True, parents=True)\n\nclass GeoWikiProcessor(BaseProcessor):\n\n    dataset = \"geowiki_landcover_2017\"\n\n    def load_raw_data(self, participants: str) -> pd.DataFrame:\n\n        participants_to_file_labels = {\n            \"all\": \"all\",\n            \"students\": \"con\",\n            \"experts\": \"exp\",\n        }\n\n        file_label = participants_to_file_labels.get(participants, participants)\n        assert (\n            file_label in participants_to_file_labels.values()\n        ), f\"Unknown participant {file_label}\"\n\n        return pd.read_csv(\n            self.raw_folder / f\"loc_{file_label}{'_2' if file_label == 'all' else ''}.txt\",\n            sep=\"\\t\",\n        )\n\n    def process(self, participants: str = \"all\") -> None:\n\n        location_data = self.load_raw_data(participants)\n\n        # first, we find the mean sumcrop calculated per location\n        mean_per_location = (\n            location_data[[\"location_id\", \"sumcrop\", \"loc_cent_X\", \"loc_cent_Y\"]]\n            .groupby(\"location_id\")\n            .mean()\n        )\n\n        # then, we rename the columns\n        mean_per_location = mean_per_location.rename(\n            {\"loc_cent_X\": \"lon\", \"loc_cent_Y\": \"lat\", \"sumcrop\": \"mean_sumcrop\"},\n            axis=\"columns\",\n            errors=\"raise\",\n        )\n        # then, we turn it into an xarray with x and y as indices\n        output_xr = (\n            mean_per_location.reset_index().set_index([\"lon\", \"lat\"])[\"mean_sumcrop\"].to_xarray()\n        )\n\n        # and save\n        output_xr.to_netcdf(self.output_folder / \"data.nc\")\n\n            \ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nprocess_geowiki()\nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 414, in <module>\n    process_geowiki()\n  File \"export_GeoWiki_sentinel_gee.py\", line 406, in process_geowiki\n    processor = GeoWikiProcessor(Path(\"../data\"))\n  File \"export_GeoWiki_sentinel_gee.py\", line 349, in __init__\n    set_seed()\n  File \"export_GeoWiki_sentinel_gee.py\", line 333, in set_seed\n    np.random.seed(seed)\nNameError: name 'np' is not defined\n",
  "history_begin_time" : 1644872261600,
  "history_end_time" : 1644872265076,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "5tjzTSnkRTLZ",
  "history_input" : "'''\nThis node process requires Google Earth Engine creds.\n'''\nfrom abc import ABC, abstractmethod\nimport pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 338, in <module>\n    export_geowiki_sentinel_ee()\n  File \"export_GeoWiki_sentinel_gee.py\", line 334, in export_geowiki_sentinel_ee\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n  File \"export_GeoWiki_sentinel_gee.py\", line 150, in __init__\n    self.labels = self.load_labels()\n  File \"export_GeoWiki_sentinel_gee.py\", line 266, in load_labels\n    assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\nAssertionError: GeoWiki processor must be run to load labels\n",
  "history_begin_time" : 1644872111531,
  "history_end_time" : 1644872115891,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "uTiKCqoYdsLA",
  "history_input" : "'''\nThis node process requires Google Earth Engine creds.\n'''\n\nimport pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union, Tuple\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 132, in <module>\n    class BaseSentinelExporter(BaseExporter, ABC):\nNameError: name 'ABC' is not defined\n",
  "history_begin_time" : 1644872071416,
  "history_end_time" : 1644872074943,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "OQmaluqaqrCz",
  "history_input" : "'''\nThis node process requires Google Earth Engine creds.\n'''\n\nimport pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union\nfrom dataclasses import dataclass\nimport ee\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 24, in <module>\n    class EEBoundingBox(BoundingBox):\n  File \"export_GeoWiki_sentinel_gee.py\", line 42, in EEBoundingBox\n    def to_metres(self) -> Tuple[float, float]:\nNameError: name 'Tuple' is not defined\n",
  "history_begin_time" : 1644872041890,
  "history_end_time" : 1644872044784,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "2oZry8884QH3",
  "history_input" : "import pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union\nfrom dataclasses import dataclass\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 19, in <module>\n    class EEBoundingBox(BoundingBox):\n  File \"export_GeoWiki_sentinel_gee.py\", line 25, in EEBoundingBox\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\nNameError: name 'ee' is not defined\n",
  "history_begin_time" : 1644871960051,
  "history_end_time" : 1644871961271,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "74Dc51sZpQU7",
  "history_input" : "import pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union\n\n@dataclass\nclass BoundingBox:\n\n    min_lon: float\n    max_lon: float\n    min_lat: float\n    max_lat: float\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 10, in <module>\n    @dataclass\nNameError: name 'dataclass' is not defined\n",
  "history_begin_time" : 1644871942476,
  "history_end_time" : 1644871943787,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "M3YymWY0YKO6",
  "history_input" : "import pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\nfrom typing import Optional, List, Any, Dict, Union\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 10, in <module>\n    class EEBoundingBox(BoundingBox):\nNameError: name 'BoundingBox' is not defined\n",
  "history_begin_time" : 1644871849469,
  "history_end_time" : 1644871850732,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "dLte7L9bSpJC",
  "history_input" : "import pandas as pd\nimport xarray as xr\nfrom datetime import date\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport urllib.request\nimport zipfile\n\n\nfrom .base import BaseSentinelExporter\nfrom src.exporters import GeoWikiExporter\nfrom .utils import EEBoundingBox, bounding_box_from_centre\n\nfrom typing import Optional, List, Any, Dict, Union\n\nclass EEBoundingBox(BoundingBox):\n    r\"\"\"\n    A bounding box with additional earth-engine specific\n    functionality\n    \"\"\"\n\n    def to_ee_polygon(self) -> ee.Geometry.Polygon:\n        return ee.Geometry.Polygon(\n            [\n                [\n                    [self.min_lon, self.min_lat],\n                    [self.min_lon, self.max_lat],\n                    [self.max_lon, self.max_lat],\n                    [self.max_lon, self.min_lat],\n                ]\n            ]\n        )\n\n    def to_metres(self) -> Tuple[float, float]:\n        r\"\"\"\n        :return: [lat metres, lon metres]\n        \"\"\"\n        # https://gis.stackexchange.com/questions/75528/understanding-terms-in-length-of-degree-formula\n        mid_lat = (self.min_lat + self.max_lat) / 2.0\n        m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n        delta_lat = self.max_lat - self.min_lat\n        delta_lon = self.max_lon - self.min_lon\n\n        return delta_lat * m_per_deg_lat, delta_lon * m_per_deg_lon\n\n    def to_polygons(self, metres_per_patch: int = 3300) -> List[ee.Geometry.Polygon]:\n\n        lat_metres, lon_metres = self.to_metres()\n\n        num_cols = int(lon_metres / metres_per_patch)\n        num_rows = int(lat_metres / metres_per_patch)\n\n        print(f\"Splitting into {num_cols} columns and {num_rows} rows\")\n\n        lon_size = (self.max_lon - self.min_lon) / num_cols\n        lat_size = (self.max_lat - self.min_lat) / num_rows\n\n        output_polygons: List[ee.Geometry.Polygon] = []\n\n        cur_lon = self.min_lon\n        while cur_lon < self.max_lon:\n            cur_lat = self.min_lat\n            while cur_lat < self.max_lat:\n                output_polygons.append(\n                    ee.Geometry.Polygon(\n                        [\n                            [\n                                [cur_lon, cur_lat],\n                                [cur_lon, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat + lat_size],\n                                [cur_lon + lon_size, cur_lat],\n                            ]\n                        ]\n                    )\n                )\n                cur_lat += lat_size\n            cur_lon += lon_size\n\n        return output_polygons\n\n\ndef bounding_box_from_centre(\n    mid_lat: float, mid_lon: float, surrounding_metres: Union[int, Tuple[int, int]]\n) -> EEBoundingBox:\n\n    m_per_deg_lat, m_per_deg_lon = metre_per_degree(mid_lat)\n\n    if isinstance(surrounding_metres, int):\n        surrounding_metres = (surrounding_metres, surrounding_metres)\n\n    surrounding_lat, surrounding_lon = surrounding_metres\n\n    deg_lat = surrounding_lat / m_per_deg_lat\n    deg_lon = surrounding_lon / m_per_deg_lon\n\n    max_lat, min_lat = mid_lat + deg_lat, mid_lat - deg_lat\n    max_lon, min_lon = mid_lon + deg_lon, mid_lon - deg_lon\n\n    return EEBoundingBox(max_lon=max_lon, min_lon=min_lon, max_lat=max_lat, min_lat=min_lat)\n\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n        \nclass BaseSentinelExporter(BaseExporter, ABC):\n\n    r\"\"\"\n    Download cloud free sentinel data for countries,\n    where countries are defined by the simplified large scale\n    international boundaries.\n    \"\"\"\n\n    dataset: str\n    min_date = date(2017, 3, 28)\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n        super().__init__(data_folder)\n        try:\n            ee.Initialize()\n        except Exception:\n            print(\"This code doesn't work unless you have authenticated your earthengine account\")\n\n        self.labels = self.load_labels()\n\n    @abstractmethod\n    def load_labels(self) -> pd.DataFrame:\n        raise NotImplementedError\n\n    def _export_for_polygon(\n        self,\n        polygon: ee.Geometry.Polygon,\n        polygon_identifier: Union[int, str],\n        start_date: date,\n        end_date: date,\n        days_per_timestep: int,\n        checkpoint: bool,\n        monitor: bool,\n        fast: bool,\n    ) -> None:\n\n        if fast:\n            export_func = cloudfree.get_single_image_fast\n        else:\n            export_func = cloudfree.get_single_image\n\n        cur_date = start_date\n        cur_end_date = cur_date + timedelta(days=days_per_timestep)\n\n        image_collection_list: List[ee.Image] = []\n\n        print(\n            f\"Exporting image for polygon {polygon_identifier} from \"\n            f\"aggregated images between {str(cur_date)} and {str(end_date)}\"\n        )\n        filename = f\"{polygon_identifier}_{str(cur_date)}_{str(end_date)}\"\n\n        if checkpoint and (self.output_folder / f\"{filename}.tif\").exists():\n            print(\"File already exists! Skipping\")\n            return None\n\n        while cur_end_date <= end_date:\n\n            image_collection_list.append(\n                export_func(region=polygon, start_date=cur_date, end_date=cur_end_date)\n            )\n            cur_date += timedelta(days=days_per_timestep)\n            cur_end_date += timedelta(days=days_per_timestep)\n\n        # now, we want to take our image collection and append the bands into a single image\n        imcoll = ee.ImageCollection(image_collection_list)\n        img = ee.Image(imcoll.iterate(cloudfree.combine_bands))\n\n        # and finally, export the image\n        cloudfree.export(\n            image=img,\n            region=polygon,\n            filename=filename,\n            drive_folder=self.dataset,\n            monitor=monitor,\n        )\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n\nclass GeoWikiSentinelExporter(BaseSentinelExporter):\n\n    dataset = \"earth_engine_geowiki\"\n\n    def load_labels(self) -> pd.DataFrame:\n        # right now, this just loads geowiki data. In the future,\n        # it would be neat to merge all labels together\n        geowiki = self.data_folder / \"processed\" / GeoWikiExporter.dataset / \"data.nc\"\n        assert geowiki.exists(), \"GeoWiki processor must be run to load labels\"\n        return xr.open_dataset(geowiki).to_dataframe().dropna().reset_index()\n\n    def labels_to_bounding_boxes(\n        self, num_labelled_points: Optional[int], surrounding_metres: int\n    ) -> List[EEBoundingBox]:\n\n        output: List[EEBoundingBox] = []\n\n        for idx, row in tqdm(self.labels.iterrows()):\n            output.append(\n                bounding_box_from_centre(\n                    mid_lat=row[\"lat\"], mid_lon=row[\"lon\"], surrounding_metres=surrounding_metres,\n                )\n            )\n\n            if num_labelled_points is not None:\n                if len(output) >= num_labelled_points:\n                    return output\n        return output\n\n    def export_for_labels(\n        self,\n        days_per_timestep: int = 1,\n        start_date: date = date(2017, 3, 28),\n        end_date: date = date(2017, 3, 29),\n        num_labelled_points: Optional[int] = None,\n        surrounding_metres: int = 80,\n        checkpoint: bool = True,\n        monitor: bool = False,\n        fast: bool = True,\n    ) -> None:\n        r\"\"\"\n        Run the GeoWiki exporter. For each label, the exporter will export\n        int( (end_date - start_date).days / days_per_timestep) timesteps of data,\n        where each timestep consists of a mosaic of all available images within the\n        days_per_timestep of that timestep.\n        :param days_per_timestep: The number of days of data to use for each mosaiced image.\n        :param start_date: The start data of the data export\n        :param end_date: The end date of the data export\n        :param num_labelled_points: (Optional) The number of labelled points to export.\n        :param surrounding_metres: The number of metres surrounding each labelled point to export\n        :param checkpoint: Whether or not to check in self.data_folder to see if the file has\n            already been exported. If it has, skip it\n        :param monitor: Whether to monitor each task until it has been run\n        :param fast: Whether to use the faster cloudfree exporter. This function is considerably\n            faster, but cloud artefacts can be more pronounced. Default = True\n        \"\"\"\n        assert start_date >= self.min_date, f\"Sentinel data does not exist before {self.min_date}\"\n\n        bounding_boxes_to_download = self.labels_to_bounding_boxes(\n            num_labelled_points=num_labelled_points, surrounding_metres=surrounding_metres,\n        )\n\n        for idx, bounding_box in enumerate(bounding_boxes_to_download):\n            self._export_for_polygon(\n                polygon=bounding_box.to_ee_polygon(),\n                polygon_identifier=idx,\n                start_date=start_date,\n                end_date=end_date,\n                days_per_timestep=days_per_timestep,\n                checkpoint=checkpoint,\n                monitor=monitor,\n                fast=fast,\n            )\n\n            \ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n    \nexport_geowiki_sentinel_ee()",
  "history_output" : "Traceback (most recent call last):\n  File \"export_GeoWiki_sentinel_gee.py\", line 10, in <module>\n    from .base import BaseSentinelExporter\nImportError: attempted relative import with no known parent package\n",
  "history_begin_time" : 1644871823293,
  "history_end_time" : 1644871825937,
  "history_notes" : null,
  "history_process" : "bj3qox",
  "host_id" : null,
  "indicator" : "Done"
},]
