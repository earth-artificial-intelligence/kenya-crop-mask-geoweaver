[{
  "id" : "yt18j7",
  "name" : "export_GeoWiki_labels",
  "description" : null,
  "code" : "\nfrom pathlib import Path\nfrom typing import Any, Dict\nimport urllib.request\nimport zipfile\n\nfrom src.exporters import (\n    GeoWikiExporter,\n    GeoWikiSentinelExporter,\n    KenyaPVSentinelExporter,\n    KenyaNonCropSentinelExporter,\n    RegionalExporter,\n    cancel_all_tasks,\n)\nfrom src_exporters_geowiki import *\nfrom src_exporters_sentinel_geowiki import *\nfrom src_exporters_sentinel_pv_kenya import *\nfrom src_exporters_sentinel_kenya_non_crop import *\nfrom src_exporters_sentinel_region import *\nfrom src_exporters_sentinel_utils import *\n\nclass BaseExporter:\n    r\"\"\"Base for all exporter classes. It creates the appropriate\n    directory in the data dir (``data_dir/raw/{dataset}``).\n\n    All classes which extend this should implement an export function.\n\n    :param data_folder (pathlib.Path, optional)``: The location of the data folder.\n            Default: ``pathlib.Path(\"data\")``\n    \"\"\"\n\n    dataset: str\n    default_args_dict: Dict[str, Any] = {}\n\n    def __init__(self, data_folder: Path = Path(\"data\")) -> None:\n\n        self.data_folder = data_folder\n\n        self.raw_folder = self.data_folder / \"raw\"\n        self.output_folder = self.raw_folder / self.dataset\n        self.output_folder.mkdir(parents=True, exist_ok=True)\n\n\n\nclass GeoWikiExporter(BaseExporter):\n    r\"\"\"\n    Download the GeoWiki labels\n    \"\"\"\n\n    dataset = \"geowiki_landcover_2017\"\n\n    download_urls = [\n        \"http://store.pangaea.de/Publications/See_2017/crop_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/crop_exp.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_all_2.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_con.zip\",\n        \"http://store.pangaea.de/Publications/See_2017/loc_exp.zip\",\n    ]\n\n    @staticmethod\n    def download_file(url: str, output_folder: Path, remove_zip: bool = True) -> None:\n\n        filename = url.split(\"/\")[-1]\n        output_path = output_folder / filename\n\n        if output_path.exists():\n            print(f\"{filename} already exists! Skipping\")\n            return None\n\n        print(f\"Downloading {url}\")\n        urllib.request.urlretrieve(url, output_path)\n\n        if filename.endswith(\"zip\"):\n\n            print(f\"Downloaded! Unzipping to {output_folder}\")\n            with zipfile.ZipFile(output_path, \"r\") as zip_file:\n                zip_file.extractall(output_folder)\n\n            if remove_zip:\n                print(\"Deleting zip file\")\n                (output_path).unlink()\n\n    def export(self, remove_zip: bool = False) -> None:\n        r\"\"\"\n        Download the GeoWiki labels\n        :param remove_zip: Whether to remove the zip file once it has been expanded\n        \"\"\"\n        for file_url in self.download_urls:\n            self.download_file(file_url, self.output_folder, remove_zip)\n\n            \ndef export_geowiki():\n    print(\"export_geowiki() will be executed now\")\n    exporter = GeoWikiExporter(Path(\"../data\"))\n    exporter.export()\n    \nexport_geowiki()",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "bj3qox",
  "name" : "export_GeoWiki_sentinel_gee",
  "description" : null,
  "code" : "# Write first python in Geoweaver",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "8q3z9d",
  "name" : "export_plant_village_sentinel_gee",
  "description" : "python",
  "code" : "",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "46fhdd",
  "name" : "export_kenya_non_crop_sentinel_gee",
  "description" : "python",
  "code" : "# Write first python in Geoweaver",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "veym8r",
  "name" : "process_kenya_crop_mask",
  "description" : "python",
  "code" : "",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "vxuhdr",
  "name" : "combine_data_labels",
  "description" : "python",
  "code" : "",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "bmgaz5",
  "name" : "model_training",
  "description" : "python",
  "code" : "",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "q31oxu",
  "name" : "model_testing",
  "description" : "python",
  "code" : "",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "gpetwx",
  "name" : "scripts_export",
  "description" : null,
  "code" : "import sys\nfrom pathlib import Path\nfrom datetime import date\n\nsys.path.append(\"..\")\n\nfrom src_exporters_geowiki import *\nfrom src_exporters_sentinel_geowiki import *\nfrom src_exporters_sentinel_pv_kenya import *\nfrom src_exporters_sentinel_kenya_non_crop import *\nfrom src_exporters_sentinel_region import *\nfrom src_exporters_sentinel_utils import *\n\ndef export_geowiki():\n    exporter = GeoWikiExporter(Path(\"../data\"))\n    exporter.export()\n\n\ndef export_geowiki_sentinel_ee():\n    exporter = GeoWikiSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n\n\ndef export_plant_village_sentinel_ee():\n    exporter = KenyaPVSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n\n\ndef export_kenya_non_crop():\n    exporter = KenyaNonCropSentinelExporter(Path(\"../data\"))\n    exporter.export_for_labels(\n        num_labelled_points=10, monitor=False, checkpoint=True)\n\n\ndef export_region():\n    exporter = RegionalExporter(Path(\"../data\"))\n    exporter.export_for_region(\n        region_name=\"Busia\",\n        end_date=date(2020, 9, 13),\n        num_timesteps=5,\n        monitor=False,\n        checkpoint=True,\n        metres_per_polygon=None,\n        fast=False,\n    )\n\n\nif __name__ == \"__main__\":\n    export_geowiki_sentinel_ee()\n    export_plant_village_sentinel_ee()\n    export_kenya_non_crop()\n    export_region()\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "iticjd",
  "name" : "scripts_process",
  "description" : "python",
  "code" : "import sys\nfrom pathlib import Path\n\nsys.path.append(\"..\")\n\nfrom src.processors import (\n    GeoWikiProcessor,\n    KenyaPVProcessor,\n    KenyaNonCropProcessor,\n)\n\n\ndef process_geowiki():\n    processor = GeoWikiProcessor(Path(\"../data\"))\n    processor.process()\n\n\ndef process_plantvillage():\n    processor = KenyaPVProcessor(Path(\"../data\"))\n    processor.process()\n\n\ndef process_kenya_noncrop():\n    processor = KenyaNonCropProcessor(Path(\"../data\"))\n    processor.process()\n\n\nif __name__ == \"__main__\":\n    process_geowiki()\n    process_plantvillage()\n    process_kenya_noncrop()\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "3cars9",
  "name" : "scripts_engineer",
  "description" : "python",
  "code" : "import sys\nfrom pathlib import Path\n\nsys.path.append(\"..\")\n\nfrom src.engineer import (\n    GeoWikiEngineer,\n    PVKenyaEngineer,\n    KenyaNonCropEngineer,\n)\n\n\ndef engineer_geowiki():\n    engineer = GeoWikiEngineer(Path(\"../data\"))\n    engineer.engineer(val_set_size=0.2)\n\n\ndef engineer_kenya():\n    engineer = PVKenyaEngineer(Path(\"../data\"))\n    engineer.engineer(val_set_size=0.1, test_set_size=0.1)\n\n\ndef engineer_kenya_noncrop():\n    engineer = KenyaNonCropEngineer(Path(\"../data\"))\n    engineer.engineer(val_set_size=0.1, test_set_size=0.1)\n\n\nif __name__ == \"__main__\":\n    engineer_geowiki()\n    engineer_kenya()\n    engineer_kenya_noncrop()",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "r5a5p5",
  "name" : "scripts_model",
  "description" : "python",
  "code" : "import sys\nfrom argparse import ArgumentParser\nfrom pathlib import Path\n\nsys.path.append(\"..\")\n\nfrom src.models import Model\nfrom src.models import train_model\n\n\nif __name__ == \"__main__\":\n    parser = ArgumentParser()\n\n    parser.add_argument(\"--max_epochs\", type=int, default=1000)\n    parser.add_argument(\"--patience\", type=int, default=10)\n\n    model_args = Model.add_model_specific_args(parser).parse_args()\n    model = Model(model_args)\n\n    train_model(model, model_args)\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "delykw",
  "name" : "scripts_predict",
  "description" : "python",
  "code" : "from pathlib import Path\nimport sys\n\nsys.path.append(\"..\")\n\nfrom src.models import Model\nfrom src.analysis import plot_results\n\n\ndef kenya_crop_type_mapper():\n    data_dir = \"../data\"\n\n    test_folder = Path(\"PATH_TO_TIF_FILES\")\n    test_files = test_folder.glob(\"*.tif\")\n    print(test_files)\n\n    model_path = \"PATH_TO_MODEL_CKPT\"\n    print(f\"Using model {model_path}\")\n\n    model = Model.load_from_checkpoint(model_path)\n\n    for test_path in test_files:\n\n        save_dir = Path(data_dir) / \"Autoencoder\"\n        save_dir.mkdir(exist_ok=True)\n\n        print(f\"Running for {test_path}\")\n\n        savepath = save_dir / f\"preds_{test_path.name}\"\n        if savepath.exists():\n            print(\"File already generated. Skipping\")\n            continue\n\n        out_forecasted = model.predict(test_path, with_forecaster=True)\n        plot_results(out_forecasted, test_path, savepath=save_dir, prefix=\"forecasted_\")\n\n        out_normal = model.predict(test_path, with_forecaster=False)\n        plot_results(out_normal, test_path, savepath=save_dir, prefix=\"full_input_\")\n\n        out_forecasted.to_netcdf(save_dir / f\"preds_forecasted_{test_path.name}.nc\")\n        out_normal.to_netcdf(save_dir / f\"preds_normal_{test_path.name}.nc\")\n\n\nif __name__ == \"__main__\":\n    kenya_crop_type_mapper()\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
},{
  "id" : "q1j13t",
  "name" : "scripts_test",
  "description" : "python",
  "code" : "import pytorch_lightning as pl\nfrom pathlib import Path\nfrom argparse import ArgumentParser\n\nimport sys\n\nsys.path.append(\"..\")\nfrom src.models import Model\n\n\ndef get_checkpoint(data_folder: Path, version: int) -> str:\n\n    log_folder = data_folder / \"lightning_logs\" / f\"version_{version}\" / \"checkpoints\"\n    checkpoint = list(log_folder.glob(\"*.ckpt\"))\n    return str(checkpoint[0])\n\n\ndef test_model():\n    parser = ArgumentParser()\n\n    parser.add_argument(\"--version\", type=int, default=0)\n\n    args = parser.parse_args()\n\n    model_path = get_checkpoint(Path(\"../data\"), args.version)\n\n    print(f\"Using model {model_path}\")\n\n    model = Model.load_from_checkpoint(model_path)\n\n    trainer = pl.Trainer()\n    trainer.test(model)\n\n\nif __name__ == \"__main__\":\n    test_model()\n",
  "lang" : "python",
  "owner" : "111111",
  "confidential" : "FALSE"
}]
